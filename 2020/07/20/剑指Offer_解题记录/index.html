<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32X32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16X16.ico">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-fill-left.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yifanzhang13.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="剑指Offer_解题记录 📝分享和记录做题的思路 哈哈">
<meta name="keywords" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="「剑指Offer系列题解」">
<meta property="og:url" content="http:&#x2F;&#x2F;yifanzhang13.github.io&#x2F;2020&#x2F;07&#x2F;20&#x2F;%E5%89%91%E6%8C%87Offer_%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95&#x2F;index.html">
<meta property="og:site_name" content="Flog">
<meta property="og:description" content="剑指Offer_解题记录 📝分享和记录做题的思路 哈哈">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-08-03T15:21:16.679Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yifanzhang13.github.io/2020/07/20/%E5%89%91%E6%8C%87Offer_%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>「剑指Offer系列题解」 | Flog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Flog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Flog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">阿酱日常写码的碎碎念</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">13</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yifanzhang13" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yifanzhang13.github.io/2020/07/20/%E5%89%91%E6%8C%87Offer_%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/pika.jpg">
      <meta itemprop="name" content="阿酱 a.k.a. Yifan Zhang">
      <meta itemprop="description" content="One Mission">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Flog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「剑指Offer系列题解」
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-20 16:29:34" itemprop="dateCreated datePublished" datetime="2020-07-20T16:29:34+08:00">2020-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-03 23:21:16" itemprop="dateModified" datetime="2020-08-03T23:21:16+08:00">2020-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="剑指Offer-解题记录"><a href="#剑指Offer-解题记录" class="headerlink" title="剑指Offer_解题记录"></a>剑指Offer_解题记录</h1><ul>
<li>📝分享和记录做题的思路</li>
<li>哈哈</li>
</ul>
<a id="more"></a>

<h2 id="Common-Used-Class"><a href="#Common-Used-Class" class="headerlink" title="Common Used Class"></a>Common Used Class</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition of a single-linked list node</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> ListNode next;</span><br><span class="line"> ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,Node _left,Node _right)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h2><h3 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06-从尾到头打印链表 "></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">06-从尾到头打印链表 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadTailLinkedNode_06</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span></span><br><span class="line"><span class="comment">     * 示例 1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：head = [1,3,2]</span></span><br><span class="line"><span class="comment">     * 输出：[2,3,1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_06_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个arraylist来储存从尾到头的element</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="comment">//创建一个list大小的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这是一个递归方法</span></span><br><span class="line"><span class="comment">         * 终止条件：当node为null的时候说明已经到尾巴了</span></span><br><span class="line"><span class="comment">         * 当终止递归的时候开始回朔</span></span><br><span class="line"><span class="comment">         * 回朔会从尾巴到头一个一个的通过list.add(node.val)把值加到list中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(node.next);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="22-链表中倒数第k个结点"><a href="#22-链表中倒数第k个结点" class="headerlink" title="22-链表中倒数第k个结点 "></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">22-链表中倒数第k个结点 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getKthFromEnd_22</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回链表 4-&gt;5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_22_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是递归的解法</span></span><br><span class="line"><span class="comment">     * 通过递归得到一个储存从尾到头的元素的list</span></span><br><span class="line"><span class="comment">     * 然后直接通过index k 来得到答案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> FindOrNot = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先递归，把element从尾巴到头储存到list中</span></span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递归解决</span></span><br><span class="line"><span class="comment">         * 从尾巴到头依次把element加到list中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(node.next);</span><br><span class="line">        list.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution_22_1</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这题用双指针</span></span><br><span class="line"><span class="comment">     * 算法流程：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head​ 。</span></span><br><span class="line"><span class="comment">     * 构建双指针距离： 前指针 former 先向前走 kkk 步（结束后，双指针 former 和 latter 间相距 kkk 步）。</span></span><br><span class="line"><span class="comment">     * 双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点 时跳出（跳出后， latter 与尾节点距离为 k−1k-1k−1，即 latter 指向倒数第 kkk 个节点）。</span></span><br><span class="line"><span class="comment">     * 返回值： 返回 latter 即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个指针最初都指向head</span></span><br><span class="line">        ListNode former=head, latter=head;</span><br><span class="line">        <span class="comment">//先让former指针移动k个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">//如果只有一个node就是head，则直接返回latter</span></span><br><span class="line">            <span class="keyword">if</span> (former==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            former = former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当former移动到头，也就是当former等于null的时候，latter就到达倒数第k个element，这时再返回latter</span></span><br><span class="line">        <span class="keyword">while</span>(former!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24-反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">24-反转链表</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseList_24</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment">     * 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_24_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是一个土办法</span></span><br><span class="line"><span class="comment">     * 先用list从尾到头来储存node的值</span></span><br><span class="line"><span class="comment">     * 然后利用递归把每一个node的val更换为list中已经反转的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        recur1(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先用递归把所有的node存起来</span></span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(node.next);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur1</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        node.val=list.get(i++);</span><br><span class="line">        recur1(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25-合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">25-合并两个排序的链表</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergeTwoLists_25</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">     * 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_25_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//伪头点</span></span><br><span class="line">    ListNode dum = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//cur先指向dum</span></span><br><span class="line">    ListNode cur = dum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur往前更新一步</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next=l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35-复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35-复杂链表的复制</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copyRandomList_35</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，</span></span><br><span class="line"><span class="comment">     * 每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_35_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用HashMap来解题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建map</span></span><br><span class="line">        HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//指向head</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//复制Node</span></span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(cur,<span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次指向head</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//复制Node的random和next</span></span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52-两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52-两个链表的第一个公共节点</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getIntersectionNode_52</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span></span><br><span class="line"><span class="comment">     * 输出：Reference of the node with value = 8</span></span><br><span class="line"><span class="comment">     * 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_52_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果两个无环链表相交,那么从相交节点开始,一直到两个链表终止的这一段,是两个链表共享的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因此解决该问题的具体过程如下:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     链表1从头节点开始，走到最后一个节点(不是结束)，统计链表1的长度记为len1，同时记录链表1的最后一个节点记为end1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     链表2从头节点开始，走到最后一个节点(不是结束)，统计链表2的长度记为len2，同时记录链表2的最后一个节点记为end2。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     如果end1!=end2，说明两个链表不相交，返回nul即可。如果end=end2，说明两个链表相交，进入步骤4来找寻第一个相交节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     如果链表1比较长，链表1就先走len1-len2步。如果链表2比较长，链表2就先走len2-len1步。然后两个链表一起走，一起走的过程中，两个链表第一次走到一起的那个节点，就是第一个相交的节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lenA=<span class="number">0</span>, lenB=<span class="number">0</span>;</span><br><span class="line">        ListNode curA = headA, curB = headB;</span><br><span class="line">        <span class="comment">//计算lenA</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算lenB</span></span><br><span class="line">        <span class="keyword">while</span> (curB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果end1!=end2，说明两个链表不相交，返回nul即可。如果end=end2，说明两个链表相交，进入步骤4来找寻第一个相交节点。</span></span><br><span class="line">        <span class="keyword">int</span> dif = (lenA-lenB);</span><br><span class="line">        curA = dif&gt;<span class="number">0</span> ? headA : headB;</span><br><span class="line">        curB = curA==headA ? headB : headA;</span><br><span class="line">        dif = Math.abs(dif);</span><br><span class="line">        <span class="keyword">if</span> (dif&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (dif &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在两个链表一起走，等两个node相等的时候就返回，因为找到了intersect point</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=curB)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回curA curB都行，因为相同</span></span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18-删除链表的节点 "></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">18-删除链表的节点 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">deleteNode_18</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回删除后的链表的头节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：此题对比原题有改动</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: head = [4,5,1,9], val = 5</span></span><br><span class="line"><span class="comment">     * 输出: [4,1,9]</span></span><br><span class="line"><span class="comment">     * 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: head = [4,5,1,9], val = 1</span></span><br><span class="line"><span class="comment">     * 输出: [4,5,9]</span></span><br><span class="line"><span class="comment">     * 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_18_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     删除值为 val 的节点可分为两步：定位节点、修改引用。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。</span></span><br><span class="line"><span class="comment">         *     修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (head.val==val) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="comment">//创建指针</span></span><br><span class="line">        ListNode cur = head, pre = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到目标节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur.val!=val)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到目标节点前面的一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(count-<span class="number">1</span>);i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除目标节点</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><h3 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09-用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/submissions/">09-用两个栈实现队列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * ["CQueue","appendTail","deleteHead","deleteHead"]</span></span><br><span class="line"><span class="comment"> * [[],[3],[],[]]</span></span><br><span class="line"><span class="comment"> * 输出：[null,null,3,-1]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * ["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]</span></span><br><span class="line"><span class="comment"> * [[],[],[5],[2],[],[]]</span></span><br><span class="line"><span class="comment"> * 输出：[null,-1,null,null,5,2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CQueue_09</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue_09</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，</span></span><br><span class="line"><span class="comment">         * 因此我们可以设计栈 A 用于加入队尾操作，</span></span><br><span class="line"><span class="comment">         * 栈 B 用于将元素倒序，从而实现删除队首元素。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//A用于加入队尾</span></span><br><span class="line">        <span class="comment">//63</span></span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除队首deleteHead()函数： 有以下三种情况。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</span></span><br><span class="line"><span class="comment">         *     否则，当 A 为空： 即两个栈都为空，无元素，因此返回 −1 。</span></span><br><span class="line"><span class="comment">         *     否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty() &amp;&amp; B.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//这里用addFirst来实现倒序</span></span><br><span class="line">                <span class="comment">//36</span></span><br><span class="line">                B.addLast(A.removeLast());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6</span></span><br><span class="line">            <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30-包含min函数的栈"></a><a href="http://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">30-包含min函数的栈</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack_30</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack_30</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 函数设计：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     push(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。</span></span><br><span class="line"><span class="comment">         *         将 xxx 压入栈 AAA （即 A.add(x) ）；</span></span><br><span class="line"><span class="comment">         *         若 ① 栈 BBB 为空 或 ② xxx 小于等于 栈 BBB 的栈顶元素，则将 xxx 压入栈 BBB （即 B.add(x) ）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     pop() 函数： 重点为保持栈 A,B 的 元素一致性 。</span></span><br><span class="line"><span class="comment">         *         执行栈 AAA 出栈（即 A.pop() ），将出栈元素记为 yyy ；</span></span><br><span class="line"><span class="comment">         *         若 yyy 等于栈 BBB 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     top() 函数： 直接返回栈 AAA 的栈顶元素即可，即返回 A.peek() 。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     min() 函数： 直接返回栈 BBB 的栈顶元素即可，即返回 B.peek() 。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//把x push到A</span></span><br><span class="line">      	A.add(x);</span><br><span class="line">        <span class="comment">//需要保持 B栈 是非严格降序</span></span><br><span class="line">      	<span class="comment">//Stack类一定要用empty()别用错，用错成isEmpty()会报错</span></span><br><span class="line">        <span class="keyword">if</span> (B.Empty() || x&lt;=B.peek())&#123;</span><br><span class="line">            <span class="comment">//如果B是空 则把x push到B</span></span><br><span class="line">            B.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer popedInt = A.pop();</span><br><span class="line">        <span class="keyword">if</span> (popedInt.equals(B.peek())) B.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31-栈的压入、弹出序列 "></a><a href="">31-栈的压入、弹出序列 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">validateStackSequences_31</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：我们可以按以下顺序执行：</span></span><br><span class="line"><span class="comment"> * push(1), push(2), push(3), push(4), pop() -&gt; 4,</span></span><br><span class="line"><span class="comment"> * push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 解释：1 不能在 2 之前弹出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_31_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     入栈操作： 按照压栈序列的顺序执行。</span></span><br><span class="line"><span class="comment">     *     出栈操作： 每次入栈后，循环判断 “栈顶元素 === 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。</span></span><br><span class="line"><span class="comment">     *     因而，在遇到 “栈顶元素 === 弹出序列的当前元素” 就应立即执行出栈。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法流程：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     初始化： 辅助栈 stackstackstack ，弹出序列的索引 iii ；</span></span><br><span class="line"><span class="comment">     *     遍历压栈序列： 各元素记为 numnumnum ；</span></span><br><span class="line"><span class="comment">     *         元素 numnumnum 入栈；</span></span><br><span class="line"><span class="comment">     *         循环出栈：若 stackstackstack 的栈顶元素 === 弹出序列元素 popped[i]popped[i]popped[i] ，则执行出栈与 i++i++i++ ；</span></span><br><span class="line"><span class="comment">     *     返回值： 若 stackstackstack 为空，则此弹出序列合法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按照顺序依次push element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek().equals(popped[n]))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58-1-翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">58-1-翻转单词顺序</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseWords_58_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "the sky is blue"</span></span><br><span class="line"><span class="comment">     * 输出: "blue is sky the"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "  hello world!  "</span></span><br><span class="line"><span class="comment">     * 输出: "world! hello"</span></span><br><span class="line"><span class="comment">     * 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 3：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "a good   example"</span></span><br><span class="line"><span class="comment">     * 输出: "example good a"</span></span><br><span class="line"><span class="comment">     * 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_58_1_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//trim()删除首尾空格 split(" ")用空格分割字符串</span></span><br><span class="line">        String[] strings = s.trim().split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=strings.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//如果stringbuilder里的string是空单词 就跳过进入下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (strings[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            stringBuilder.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">59 - I. 滑动窗口的最大值</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maxSlidingWindow_59_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_59_1_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span> || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化返回的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>-k,j=<span class="number">0</span>;j&lt;nums.length; i++,j++)&#123;</span><br><span class="line">            <span class="comment">//通过removefirst来删除deque中和nums对应的element</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; deque.peekFirst()==nums[i-<span class="number">1</span>]) deque.removeFirst();</span><br><span class="line">            <span class="comment">//while递减deque</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;nums[j]) deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>) res[i]=deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="40-最小的K个数"><a href="#40-最小的K个数" class="headerlink" title="40-最小的K个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">40-最小的K个数</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getLeastNumbers_40</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span> || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">        Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * This method returns the value zero if (x==y),</span></span><br><span class="line"><span class="comment">                 * if (x &lt; y) then it returns a value less than zero</span></span><br><span class="line"><span class="comment">                 * and if (x &gt; y) then it returns a value greater than zero.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o2,o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            <span class="comment">//如果e小于当前heap中栈顶的最大的元素才添加e</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size()&lt;k || heap.peek()&gt;e) heap.offer(e);</span><br><span class="line">            <span class="comment">//如果当前heap的size大于k则把栈顶元素弹出去</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size()&gt;k) heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将heap中最小的k个数加入到res数组里并return</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap)&#123;</span><br><span class="line">            res[i++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50-第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50-第一个只出现一次的字符</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c:sc)&#123;</span><br><span class="line">    <span class="comment">//!dic.containsKey(c)导致第一次添加key的时候，value是true，但是再次添加的时候就是false</span></span><br><span class="line">    <span class="comment">//跟本题符合，因为只需要出现依次的char，也就是说如果value为false则不是只出现一次的char</span></span><br><span class="line">    dic.put(c,!dic.containsKey(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c:sc)</span><br><span class="line">    <span class="comment">//只出现一次的key的value是true，如果dic,get()返回true，说明是我们要找的char</span></span><br><span class="line">    <span class="keyword">if</span> (dic.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Graph-DFS-amp-BFS"><a href="#Graph-DFS-amp-BFS" class="headerlink" title="Graph (DFS &amp; BFS)"></a>Graph (DFS &amp; BFS)</h2><h3 id="12-矩阵中的路径-DFS"><a href="#12-矩阵中的路径-DFS" class="headerlink" title="12-矩阵中的路径(DFS)"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">12-矩阵中的路径(DFS)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_12_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ②</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=board.length || i&lt;<span class="number">0</span> || j&gt;=board[<span class="number">0</span>].length || j&lt;<span class="number">0</span> || board[i][j]!=word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//字符串 word 已全部匹配，即 k = len(word) - 1 。</span></span><br><span class="line">        <span class="keyword">if</span> (k==word.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//将当前char存起来</span></span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">//将当前char的位置标记为/，防治再次遍历当前的char，走回头路</span></span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">        <span class="comment">//可以上下左右移动，只要有一个方向符合要求就可以</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>) || dfs(board, word, i, j-<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, word, i-<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">                || dfs(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复char，因为其他递归里还需要走过这个char</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-机器人的运动范围-DFS"><a href="#13-机器人的运动范围-DFS" class="headerlink" title="13-机器人的运动范围(DFS)"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">13-机器人的运动范围(DFS)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_13_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="comment">//辅助矩阵</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m=m;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> si, <span class="keyword">int</span> sj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=m || j&gt;=n || si+sj&gt;k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递推工作：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</span></span><br><span class="line"><span class="comment">         *     搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      	<span class="comment">//注意数位和的增量公式</span></span><br><span class="line">        <span class="comment">//(x + 1) % 10 != 0 ? s_x + 1 : s_x - 8</span></span><br><span class="line">        <span class="comment">//s_x为x的数位和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj)+dfs(i,j+<span class="number">1</span>,si,(j+<span class="number">1</span>)%<span class="number">10</span>!=<span class="number">0</span>?sj+<span class="number">1</span>:sj-<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Fibonacci-Dynamic-Programming"><a href="#Fibonacci-Dynamic-Programming" class="headerlink" title="Fibonacci (Dynamic Programming)"></a>Fibonacci (Dynamic Programming)</h2><h3 id="10-1-斐波拉契数列"><a href="#10-1-斐波拉契数列" class="headerlink" title="10-1-斐波拉契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">10-1-斐波拉契数列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib_10_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果仅仅是用简单递归，在时间复杂度闪就会WA，然后就需要用动态规划的想法去简化计算量。</span></span><br><span class="line"><span class="comment">     * 对于这个问题，我的思路是从小到大算回去，把沿途的结果进行记录，推到n。</span></span><br><span class="line"><span class="comment">     * 关于题目描述中的取模这里提一句，要在计算中就取，不要等到结果再取，在计算过程中就已经达到取模要求了，如果没有取，可能会溢出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划解析：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     状态定义： 设 dp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 i 个数字 。</span></span><br><span class="line"><span class="comment">     *     转移方程： dp[i]=dp[i-1]+dp[i−2]，即对应数列定义 F(N) = F(N - 1) + F(N - 2)</span></span><br><span class="line"><span class="comment">     *     初始状态： dp[0]=1 dp[1]=1 ，即初始化前两个数字；</span></span><br><span class="line"><span class="comment">     *     返回值： dp[n]] ，即斐波那契数列的第 n 个数字。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_10_1_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//在计算中就曲摸，不然会溢出</span></span><br><span class="line">            dp[i] = dp[i]%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2-青蛙跳台阶问题 "></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">10-2-青蛙跳台阶问题 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">numWays_10_2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划解析：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     状态定义： 设 dp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 i 个数字 。</span></span><br><span class="line"><span class="comment">     *     转移方程： dp[i]=dp[i-1]+dp[i−2]，即对应数列定义 F(N) = F(N - 1) + F(N - 2)</span></span><br><span class="line"><span class="comment">     *     初始状态： dp[0]=1 dp[1]=1 dp[2]=2 ，即初始化前三个数字；</span></span><br><span class="line"><span class="comment">     *     返回值： dp[n]] ，即斐波那契数列的第 n 个数字。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_10_2_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Searching-Algorithms-Binary-Search"><a href="#Searching-Algorithms-Binary-Search" class="headerlink" title="Searching Algorithms (Binary Search)"></a>Searching Algorithms (Binary Search)</h2><h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04-二维数组中的查找 "></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">04-二维数组中的查找 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findNumberIn2DArray_04</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_04_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//线性查找 Linear Search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> i = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 则 int flag = matrix[i][j] 代表左下角元素（标志数）</span></span><br><span class="line"><span class="comment">         * 左下角元素： 为所在列最大元素，所在行最小元素</span></span><br><span class="line"><span class="comment">         * 如果flag大于target，就到上一行找，也就是i--，因为已知flag是所在行最小的元素</span></span><br><span class="line"><span class="comment">         * 如果flag小于target，就到下一列，j++，因为flag是这一列最大的元素</span></span><br><span class="line"><span class="comment">         * 如果flag ==  target，则return true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]&gt;target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]&lt;target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_04_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分查找  Binary Search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路分析：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 要查找矩阵中是否存在某个元素，并且表示矩阵每一行的数组都是有序的，可以对每一行进行二分查找，如果每一行都没有查找到结果，就返回false。</span></span><br><span class="line"><span class="comment">         *     使用java库函数Arrays.binarySearch(matrix[i], target)，返回值非负说明查找到target。</span></span><br><span class="line"><span class="comment">         * 还需要处理一些特殊情况：</span></span><br><span class="line"><span class="comment">         *     给定的矩阵为null或者给定的矩阵不存在任何元素matrix.length == 0 || matrix[0].length == 0，肯定找不到目标元素，直接返回。</span></span><br><span class="line"><span class="comment">         *     矩阵的每一列也是从小到达排列的，所以在对每一行进行二分查找的循环是，如果matrix[i][0] &gt; target，</span></span><br><span class="line"><span class="comment">         *     这一行肯定没有指定元素，更下面的每一行的所有元素都大于matrix[i][0]也一定找不到指定元素，所以可以直接返回false。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.binarySearch(matrix[i],target)是非零数则表示该行含有target</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.binarySearch(matrix[i],target)&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果matrix[i][0]&gt;target这一行就不包括target，因为matrix[i][0]是该行第一个元素，每一列和每一行都是递增的，如果第一个元素</span></span><br><span class="line">            <span class="comment">//都比target大，那说明该行不包含该元素，且因为递增，下一行的第一个元素一定比target大，所以return false结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-旋转数组的最小数字（二分查找）"><a href="#11-旋转数组的最小数字（二分查找）" class="headerlink" title="11-旋转数组的最小数字（二分查找）"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">11-旋转数组的最小数字（二分查找）</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">minArray_11</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_11_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//沙雕做法</span></span><br><span class="line">    <span class="comment">//笔试的时候可以用，面试别用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_11_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分搜索 Binary Search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设计两个指针i和j分别指向0和numbers.length-1</span></span><br><span class="line"><span class="comment">         * m = (i+j)/2 是中间数，那么会有三种情况</span></span><br><span class="line"><span class="comment">         * 1：numbers[m]&lt;numbers[j] 说明m在右边数组[m+1,j]，旋转点在[i,m], 所以更新j=m，m=(i+j)/2</span></span><br><span class="line"><span class="comment">         * 2：number[m]&gt;numbers[j] 说明m在左边数组,旋转点在[m+1,j]，所以更新i=m+1,m=(i+j)/2</span></span><br><span class="line"><span class="comment">         * 3：number[m]==numbers[j] 无法判断 mmm 在哪个排序数组中，即无法判断旋转点在 [i,m] 还是 [m+1,j] 区间中。</span></span><br><span class="line"><span class="comment">         * 解决方案： 执行 j=j−1 缩小判断范围</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j= numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m]&lt;numbers[j])&#123;</span><br><span class="line">                j=m;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[m]&gt;numbers[j])&#123;</span><br><span class="line">                i=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[m]==numbers[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_11_2</span></span>&#123;</span><br><span class="line">    <span class="comment">//暴力法 居然是这三种办法里最快的QAQ</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i]&lt;numbers[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1-数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">56-1-数组中数字出现的次数</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleNumbers_56_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 难点主要在于对mask的理解。mask是一个二进制数，且其中只有一位是1，其他位全是0，</span></span><br><span class="line"><span class="comment">     * 比如000010，表示我们用倒数第二位作为分组标准，倒数第二位是0的数字分到一组，倒数第二位是1的分到另一组。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么如何得到这个mask?因为我们分组的目的就是将两个不重复数字分开，</span></span><br><span class="line"><span class="comment">     * 这两个不重复数字的二进制表示肯定是不同的，但是我们没必要一位一位地比较，我们可以从右到左，找到第一个不相同的位，将mask当中这一位变成1,就得到了mask。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比如[2,2,3,3,4,6]中，不重复的两个数字是4，6，4和6的异或结果（也是整个数组的异或结果）是010，</span></span><br><span class="line"><span class="comment">     * 表示从右到左，第一次出现不同是在倒数第二位，那么可以确定，mask的倒数第二位是1，其他位是0，即</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_56_1_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//xor用来计算nums的异或和</span></span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算异或和 并存到xor</span></span><br><span class="line">        <span class="comment">// e.g. [2,4,2,3,3,6] 异或和：(2^2)^(3^3)^(4^6)=2=010</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) xor ^= num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置mask为1，则二进制为0001</span></span><br><span class="line">        <span class="comment">// mask是一个二进制数，且其中只有一位是1，其他位全是0，比如000010，</span></span><br><span class="line">        <span class="comment">// 表示我们用倒数第二位作为分组标准，倒数第二位是0的数字分到一组，倒数第二位是1的分到另一组</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &amp; operator只有1&amp;1时等于1 其余等于0</span></span><br><span class="line">        <span class="comment">// 用上面的e.g. 4和6的二进制是不同的 我们从右到左找到第一个不同的位就可以分组 4=0100 6=0110</span></span><br><span class="line">        <span class="comment">// 根据e.g. 010 &amp; 001 = 000 = 0则 mask=010</span></span><br><span class="line">        <span class="comment">// 010 &amp; 010 != 0 所以mask=010</span></span><br><span class="line">        <span class="comment">// 之后就可以用mask来将数组里的两个数分区分开</span></span><br><span class="line">        <span class="keyword">while</span>((xor &amp; mask)==<span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个只出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//根据&amp;是否为0区分将两个数字分区，并分别求异或和</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask)==<span class="number">0</span>) a ^= num;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Permutation"><a href="#Permutation" class="headerlink" title="Permutation"></a>Permutation</h2><h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38-字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/submissions/">38-字符串的排列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把参数string换为char数组</span></span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="comment">//记录每一种可能，最后转换成数组return</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        <span class="comment">//从c的第一位字符开始</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(x==c.length-<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(c));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">            <span class="comment">//HashSet用来剪枝，避免重复</span></span><br><span class="line">            <span class="comment">//例如 c=[a,b,b], 如果没有剪枝，就会有四个abb</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            <span class="comment">//e.g. c=[a,b,c]</span></span><br><span class="line">            <span class="comment">//这是第一层，也就是第一位上的字符的选择，通过调换来更换位置</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">            <span class="comment">//进入第二层，在e.g.第二层里会有两种选择，然后第二层里再递归第三层</span></span><br><span class="line">            <span class="comment">//第三层会出发终止条件 res会加上当前的可能</span></span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，把调换的位置再换回来</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42-连续子数组的最大和 "></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/submissions/">42-连续子数组的最大和 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//说明dp[i-1]对dp[i]是负贡献</span></span><br><span class="line">                <span class="comment">//dp[i-1]+nums[i]小于nums[i]</span></span><br><span class="line">                <span class="comment">//所以我们直接从当前nums[i]为开头的连续子数组来数就行</span></span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//不要用 Arrays.sort() 或者Arrays.stream().min().getAsInt()</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19-正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">19-正则表达式匹配</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Bitwise-Operation"><a href="#Bitwise-Operation" class="headerlink" title="Bitwise Operation"></a>Bitwise Operation</h2><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15-二进制中1的个数 "></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">15-二进制中1的个数 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n-1 代表 二进制n的最右边的1变成0，然后这个1右边的0变成1</span></span><br><span class="line">        <span class="comment">// n = n &amp; (n-1) 代表 二进制n最右边的1变成0，其余不变</span></span><br><span class="line">        <span class="comment">// e.g. n = 110001000 n-1=110000111</span></span><br><span class="line">        <span class="comment">// n &amp;= (n-1) -&gt; n = 110000000</span></span><br><span class="line">        <span class="comment">//在每一次循环中都消去n的最右边的1 并且res++ 当n中不含有1的时候终止循环</span></span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//n&amp;1只有两种可能分别是0和1</span></span><br><span class="line">            res += n&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//本题要求把数字 nnn 看作无符号数，因此使用 无符号右移 操作</span></span><br><span class="line">            <span class="comment">// java中是&gt;&gt;&gt;=</span></span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个是土方法做的 虽然能做出来但是时间空间复杂度高 性能差</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用Integer.toBinaryString().length来计算转换为二进制的数的长度</span></span><br><span class="line">        <span class="comment">// 也就是从二进制的一位一位的算</span></span><br><span class="line">        <span class="comment">// mask = 00000001</span></span><br><span class="line">        <span class="comment">// 如果 n&amp;mask !=0 说明 对应mask的1的位置的n的位置是1 则res++</span></span><br><span class="line">        <span class="comment">// 每次循环都将mask往左边移动 才检测n的左边一位是否是1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Integer.toBinaryString(n).length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; mask)!=<span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个是土方法做的 虽然能做出来但是时间空间复杂度高 性能差</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = Integer.toBinaryString(n).length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_4</span></span>&#123;</span><br><span class="line">    <span class="comment">//最简洁 = 性能最差哈哈哈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toBinaryString(n).replaceAll(<span class="string">"0"</span>, <span class="string">""</span>).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16-数值的整数次方 "></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">16-数值的整数次方 </a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_16_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//e.g. 2^10 x=2.0 n=9=1001</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//Java 代码中 int32 变量 n∈[−2147483648,2147483647],</span></span><br><span class="line">        <span class="comment">// 因此当 n=−2147483648n 时执行 n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</span></span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是n是负数就换成正数 x换成x^-1就行 也就是1/x</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// res = 1*2 = 2</span></span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>阿酱 a.k.a. Yifan Zhang
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://yifanzhang13.github.io/2020/07/20/%E5%89%91%E6%8C%87Offer_%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/" title="「剑指Offer系列题解」">http://yifanzhang13.github.io/2020/07/20/剑指Offer_解题记录/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tags"></i> LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/14/MachineLearning-Notes/" rel="prev" title="MachineLearning_Notes">
      <i class="fa fa-chevron-left"></i> MachineLearning_Notes
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#剑指Offer-解题记录"><span class="nav-number">1.</span> <span class="nav-text">剑指Offer_解题记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Common-Used-Class"><span class="nav-number">1.1.</span> <span class="nav-text">Common Used Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">1.2.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#06-从尾到头打印链表"><span class="nav-number">1.2.1.</span> <span class="nav-text">06-从尾到头打印链表 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-链表中倒数第k个结点"><span class="nav-number">1.2.2.</span> <span class="nav-text">22-链表中倒数第k个结点 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-反转链表"><span class="nav-number">1.2.3.</span> <span class="nav-text">24-反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-合并两个排序的链表"><span class="nav-number">1.2.4.</span> <span class="nav-text">25-合并两个排序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-复杂链表的复制"><span class="nav-number">1.2.5.</span> <span class="nav-text">35-复杂链表的复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-两个链表的第一个公共节点"><span class="nav-number">1.2.6.</span> <span class="nav-text">52-两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-删除链表的节点"><span class="nav-number">1.2.7.</span> <span class="nav-text">18-删除链表的节点 </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-amp-Queue"><span class="nav-number">1.3.</span> <span class="nav-text">Stack &amp; Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#09-用两个栈实现队列"><span class="nav-number">1.3.1.</span> <span class="nav-text">09-用两个栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-包含min函数的栈"><span class="nav-number">1.3.2.</span> <span class="nav-text">30-包含min函数的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-栈的压入、弹出序列"><span class="nav-number">1.3.3.</span> <span class="nav-text">31-栈的压入、弹出序列 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-1-翻转单词顺序"><span class="nav-number">1.3.4.</span> <span class="nav-text">58-1-翻转单词顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-I-滑动窗口的最大值"><span class="nav-number">1.3.5.</span> <span class="nav-text">59 - I. 滑动窗口的最大值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap"><span class="nav-number">1.4.</span> <span class="nav-text">Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#40-最小的K个数"><span class="nav-number">1.4.1.</span> <span class="nav-text">40-最小的K个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-Table"><span class="nav-number">1.5.</span> <span class="nav-text">Hash Table</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#50-第一个只出现一次的字符"><span class="nav-number">1.5.1.</span> <span class="nav-text">50-第一个只出现一次的字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-DFS-amp-BFS"><span class="nav-number">1.6.</span> <span class="nav-text">Graph (DFS &amp; BFS)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-矩阵中的路径-DFS"><span class="nav-number">1.6.1.</span> <span class="nav-text">12-矩阵中的路径(DFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-机器人的运动范围-DFS"><span class="nav-number">1.6.2.</span> <span class="nav-text">13-机器人的运动范围(DFS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fibonacci-Dynamic-Programming"><span class="nav-number">1.7.</span> <span class="nav-text">Fibonacci (Dynamic Programming)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-斐波拉契数列"><span class="nav-number">1.7.1.</span> <span class="nav-text">10-1-斐波拉契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-青蛙跳台阶问题"><span class="nav-number">1.7.2.</span> <span class="nav-text">10-2-青蛙跳台阶问题 </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Searching-Algorithms-Binary-Search"><span class="nav-number">1.8.</span> <span class="nav-text">Searching Algorithms (Binary Search)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#04-二维数组中的查找"><span class="nav-number">1.8.1.</span> <span class="nav-text">04-二维数组中的查找 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-旋转数组的最小数字（二分查找）"><span class="nav-number">1.8.2.</span> <span class="nav-text">11-旋转数组的最小数字（二分查找）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-1-数组中数字出现的次数"><span class="nav-number">1.8.3.</span> <span class="nav-text">56-1-数组中数字出现的次数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Permutation"><span class="nav-number">1.9.</span> <span class="nav-text">Permutation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#38-字符串的排列"><span class="nav-number">1.9.1.</span> <span class="nav-text">38-字符串的排列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-Programming"><span class="nav-number">1.10.</span> <span class="nav-text">Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#42-连续子数组的最大和"><span class="nav-number">1.10.1.</span> <span class="nav-text">42-连续子数组的最大和 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-正则表达式匹配"><span class="nav-number">1.10.2.</span> <span class="nav-text">19-正则表达式匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitwise-Operation"><span class="nav-number">1.11.</span> <span class="nav-text">Bitwise Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-二进制中1的个数"><span class="nav-number">1.11.1.</span> <span class="nav-text">15-二进制中1的个数 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-数值的整数次方"><span class="nav-number">1.11.2.</span> <span class="nav-text">16-数值的整数次方 </span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="阿酱 a.k.a. Yifan Zhang"
      src="/images/pika.jpg">
  <p class="site-author-name" itemprop="name">阿酱 a.k.a. Yifan Zhang</p>
  <div class="site-description" itemprop="description">One Mission</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yifanzhang13" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yifanzhang13" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/yifan.zhang.14224/" title="Facebook → https:&#x2F;&#x2F;www.facebook.com&#x2F;yifan.zhang.14224&#x2F;" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿酱 a.k.a. Yifan Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">126k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">1:55</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

  

  <script async src="/js/cursor/fireworks.js"></script>

</body>
</html>
