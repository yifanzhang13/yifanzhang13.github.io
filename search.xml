<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CyclicBarrier-源码分析</title>
    <url>/2020/05/29/CyclicBarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>CyclicBarrier是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点(common barrier  point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时CyclicBarrier很有用。因为该barrier在释放等待线程后可以重用，所以称它为循环的barrier</p>
<a id="more"></a>

<h1 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2 内部类"></a>2 内部类</h1><p>该内部类用于标记一次Barrier生命周期的状态</p>
<ol>
<li>true：Barrier被打断，调用await()方法将会抛出BrokenBarrierException异常</li>
<li>false：Barrier有效</li>
</ol>
<p>一次Barrier生命周期中Barrier的状态不会影响到下一次生命周期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Each use of the barrier is represented as a generation instance.</span></span><br><span class="line"><span class="comment"> * The generation changes whenever the barrier is tripped, or</span></span><br><span class="line"><span class="comment"> * is reset. There can be many generations associated with threads</span></span><br><span class="line"><span class="comment"> * using the barrier - due to the non-deterministic way the lock</span></span><br><span class="line"><span class="comment"> * may be allocated to waiting threads - but only one of these</span></span><br><span class="line"><span class="comment"> * can be active at a time (the one to which &#123;<span class="doctag">@code</span> count&#125; applies)</span></span><br><span class="line"><span class="comment"> * and all the rest are either broken or tripped.</span></span><br><span class="line"><span class="comment"> * There need not be an active generation if there has been a break</span></span><br><span class="line"><span class="comment"> * but no subsequent reset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-字段"><a href="#3-字段" class="headerlink" title="3 字段"></a>3 字段</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">/* The command to run when tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">/** The current generation */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment"> * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment"> * generation or when broken.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>lock</strong>：重入锁</li>
<li><strong>trip</strong>：条件对象，是AQS-ConditionObject内部类</li>
<li><strong>parties</strong>：到达barrier的物体数量</li>
<li><strong>barrierCommand</strong>：为了增加CyclicBarrier的生命周期，当足够多的线程通过屏障时，调用相应的处理逻辑，可由构造方法传入</li>
<li><strong>generation</strong>：标记本次生命周期的Barrier的状态，如果为true，则Barrier失效。到了next Generation后，又会重新指向一个新的Generation对象</li>
<li><strong>count</strong>：计数值</li>
</ul>
<h1 id="4-重要方法"><a href="#4-重要方法" class="headerlink" title="4 重要方法"></a>4 重要方法</h1><h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and</span></span><br><span class="line"><span class="comment"> * does not perform a predefined action when the barrier is tripped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment"> * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment"> * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment"> *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-await"><a href="#4-2-await" class="headerlink" title="4.2 await"></a>4.2 await</h2><p>await方法阻塞当前线程直至累计有count（构造方法的参数）个线程阻塞在了await方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits until all &#123;<span class="doctag">@linkplain</span> #getParties parties&#125; have invoked</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> await&#125; on this barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is not the last to arrive then it is</span></span><br><span class="line"><span class="comment"> * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment"> * one of the following things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The last thread arrives; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * the current thread; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * one of the other waiting threads; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread times out while waiting for barrier; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes &#123;<span class="doctag">@link</span> #reset&#125; on this barrier.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread's</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the barrier is &#123;<span class="doctag">@link</span> #reset&#125; while any thread is waiting,</span></span><br><span class="line"><span class="comment"> * or if the barrier &#123;<span class="doctag">@linkplain</span> #isBroken is broken&#125; when</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> await&#125; is invoked, or while any thread is waiting, then</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BrokenBarrierException&#125; is thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If any thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting,</span></span><br><span class="line"><span class="comment"> * then all other waiting threads will throw</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BrokenBarrierException&#125; and the barrier is placed in the broken</span></span><br><span class="line"><span class="comment"> * state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is the last thread to arrive, and a</span></span><br><span class="line"><span class="comment"> * non-null barrier action was supplied in the constructor, then the</span></span><br><span class="line"><span class="comment"> * current thread runs the action before allowing the other threads to</span></span><br><span class="line"><span class="comment"> * continue.</span></span><br><span class="line"><span class="comment"> * If an exception occurs during the barrier action then that exception</span></span><br><span class="line"><span class="comment"> * will be propagated in the current thread and the barrier is placed in</span></span><br><span class="line"><span class="comment"> * the broken state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the arrival index of the current thread, where index</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> getParties() - 1&#125; indicates the first</span></span><br><span class="line"><span class="comment"> *         to arrive and zero indicates the last to arrive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread was interrupted</span></span><br><span class="line"><span class="comment"> *         while waiting</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BrokenBarrierException if &lt;em&gt;another&lt;/em&gt; thread was</span></span><br><span class="line"><span class="comment"> *         interrupted or timed out while the current thread was</span></span><br><span class="line"><span class="comment"> *         waiting, or the barrier was reset, or the barrier was</span></span><br><span class="line"><span class="comment"> *         broken when &#123;<span class="doctag">@code</span> await&#125; was called, or the barrier</span></span><br><span class="line"><span class="comment"> *         action (if present) failed due to an exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">//cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-1-dowait"><a href="#4-2-1-dowait" class="headerlink" title="4.2.1 dowait"></a>4.2.1 dowait</h3><p>dowait方法是实现CyclicBarrier语义的主要方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是broken状态，则抛出BrokenBarrierException异常。该bool值在breakBarrier方法中被设置为true</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果被中断了则设置broken为true，然后抛出InterruptedException异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递减count</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//如果index为0，说明有足够多的线程调用了await方法，此时应该放行所有线程</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">//tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">//执行一些额外的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">//如果在执行run方法中抛出了任何异常，则ranAction为false状态</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//进入下一个生命周期</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">//将Barrier的当前生命周期的状态标记为不可用</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//阻塞当前线程直至被中断，打断或者超时</span></span><br><span class="line">        <span class="comment">//loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果不允许超时，将当前线程直接挂起，阻塞在条件对象trip的condition queue(ConditionObject中维护的等待队列)中</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">//如果允许超时，阻塞在条件对象trip的condition queue中一段时间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">//当Barrier处于有效状态</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">//设置为打断状态</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">//been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">//"belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果Barrier被打断，则抛出BrokenBarrierException异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//意味着调用await时处于上一个生命周期，而此时却进入了下一个生命周期中</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//允许超时，并且已经超时</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-nextGeneration"><a href="#4-2-2-nextGeneration" class="headerlink" title="4.2.2 nextGeneration"></a>4.2.2 nextGeneration</h3><p>该方法使得CyclicBarrier进入下一次生命周期，唤醒阻塞在trip上的线程，并且重置所有状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Updates state on barrier trip and wakes up everyone.</span></span><br><span class="line"><span class="comment"> * Called only while holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//signal completion of last generation</span></span><br><span class="line">    <span class="comment">//唤醒所有阻塞在condition queue中的线程，即那些阻塞在await方法上的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">//set up next generation</span></span><br><span class="line">    <span class="comment">//这就是CyclicBarrier可重用的原因</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">//重新生成Generation</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-isBroken"><a href="#4-3-isBroken" class="headerlink" title="4.3 isBroken"></a>4.3 isBroken</h2><p>检查当前Barrier生命周期是否有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queries if this barrier is in a broken state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if one or more parties broke out of this</span></span><br><span class="line"><span class="comment"> *         barrier due to interruption or timeout since</span></span><br><span class="line"><span class="comment"> *         construction or the last reset, or a barrier action</span></span><br><span class="line"><span class="comment"> *         failed due to an exception; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-reset"><a href="#4-4-reset" class="headerlink" title="4.4 reset"></a>4.4 reset</h2><p>重置Barrier，使其进入下一个生命周期。对于那些阻塞在上一个生命周期中的线程，会通过nextGeneration方法进行唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the barrier to its initial state.  If any parties are</span></span><br><span class="line"><span class="comment"> * currently waiting at the barrier, they will return with a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * a breakage has occurred for other reasons can be complicated to</span></span><br><span class="line"><span class="comment"> * carry out; threads need to re-synchronize in some other way,</span></span><br><span class="line"><span class="comment"> * and choose one to perform the reset.  It may be preferable to</span></span><br><span class="line"><span class="comment"> * instead create a new barrier for subsequent use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">//break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">//start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-getNumberWaiting"><a href="#4-5-getNumberWaiting" class="headerlink" title="4.5 getNumberWaiting"></a>4.5 getNumberWaiting</h2><p>检查有多少个线程阻塞在await方法的调用中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of parties currently waiting at the barrier.</span></span><br><span class="line"><span class="comment"> * This method is primarily useful for debugging and assertions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of parties currently blocked in &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parties - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2019/11/14/First-Blog/</url>
    <content><![CDATA[<p>Hello World!</p>
<p>Personal Blog Test!</p>
<p>Done!</p>
]]></content>
      <categories>
        <category>Hello World!</category>
      </categories>
      <tags>
        <tag>Hello World!</tag>
      </tags>
  </entry>
  <entry>
    <title>COMP0141 Security</title>
    <url>/2020/04/08/COMP0141-Security/</url>
    <content><![CDATA[<h1 id="Lecture-1-1"><a href="#Lecture-1-1" class="headerlink" title="Lecture 1-1"></a>Lecture 1-1</h1><h2 id="CIA-Triangle"><a href="#CIA-Triangle" class="headerlink" title="CIA Triangle"></a>CIA Triangle</h2><ul>
<li>Components<ul>
<li><strong>Confidentiality</strong>: Keeping Data private, only authorized users and processes should be able to access or modify data</li>
<li><strong>Integrity</strong>: System and data have not been improperly altered, data should be maintained in a correct state and nobody should be able  to improperly modify it, either accidentally or maliciously</li>
<li><strong>Availability</strong>: The ability to use the system as anticipated</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="Security-Design"><a href="#Security-Design" class="headerlink" title="Security Design"></a>Security Design</h2><ul>
<li>How to define a secure system?<ul>
<li>Secure physical facility</li>
<li>Contactless payment protocol</li>
<li>Online database</li>
<li>Private online communication</li>
</ul>
</li>
<li>We need a specified security policy to define a secure system, how to define a security policy?</li>
<li>What should Policy address?<ul>
<li><u><strong>Threat Model</strong></u><ul>
<li>Threats (Attacker-centric)</li>
<li>Vulnerabilities (System-centric)</li>
<li>Likelihood</li>
<li>Impact (Asset-centric)</li>
<li>Protection  (Cost) </li>
</ul>
</li>
</ul>
</li>
<li>Security Policy is a type of <strong>risk assessment</strong></li>
<li><strong>Threats (Who is the adversary?)</strong><ul>
<li>Consider adversary across 2 dimensions:<ul>
<li><strong>Capabilities</strong>: Who are they?</li>
<li><strong>Motivation</strong>: Why do they do it?</li>
</ul>
</li>
</ul>
</li>
<li><strong>Vulnerabilities (where can system break?)</strong><ul>
<li>Define vulnerabilities with respect to threats</li>
<li>Threat v.s. Vulnerabilities<ul>
<li>If there is a water pool, threat is water may overflow, vulnerability may be a crack of the pool</li>
</ul>
</li>
</ul>
</li>
<li><strong>Likelihood (might this happen?)</strong><ul>
<li>Define likelihood with respect to vulnerabilities </li>
<li>Vulnerability vs. Likelihood<ul>
<li>Zero if we never add water</li>
</ul>
</li>
</ul>
</li>
<li><strong>Impact (what if bad things happen?)</strong><ul>
<li>Define impact with respect to threat</li>
<li>Threat? Water might overflow. Impact? Depends on what’s nearby.</li>
</ul>
</li>
<li><strong>Protection (what does it cost?)</strong><ul>
<li>most of academic computer security is <strong>protection</strong></li>
</ul>
</li>
</ul>
<h2 id="Competing-Philosophies"><a href="#Competing-Philosophies" class="headerlink" title="Competing Philosophies"></a>Competing Philosophies</h2><ul>
<li>Binary Model<ul>
<li>Secure or Insecure<ul>
<li>Binary Model is <strong>longevity</strong> but also <strong>brittle</strong> and <strong>expensive</strong></li>
</ul>
</li>
</ul>
</li>
<li>Risk Management Model<ul>
<li>It minimise the biggest threats and focus on the <strong>cost</strong></li>
<li>It is <strong>adaptive</strong> but the solutions are usually quite reactive so lead to <strong>Arms Race</strong></li>
</ul>
</li>
</ul>
<h2 id="Is-the-System-Secure"><a href="#Is-the-System-Secure" class="headerlink" title="Is the System Secure?"></a>Is the System Secure?</h2><p><code>Security is not an absolute property, depends on having a good threat model that captures a range of adversarial behaviours</code></p>
<h2 id="Security-Mechanism"><a href="#Security-Mechanism" class="headerlink" title="Security Mechanism"></a>Security Mechanism</h2><blockquote>
<p>A system is “secure” if there is a security argument that an adversary constrained by a <strong>specific threat model</strong> cannot violate the <strong>security policy</strong></p>
<p><strong>Security argument</strong>: rigorous argument that the security mechanisms are maintaining the security policy (subject to the assumptions of the threat model)</p>
<p><strong>Security mechanism</strong>: Technical mechanism used to ensure that the security policy is not violated by an adversary operating within the threat model</p>
</blockquote>
<h1 id="Lecture-1-2"><a href="#Lecture-1-2" class="headerlink" title="Lecture 1-2"></a>Lecture 1-2</h1><h2 id="Security-and-Human-Behavior"><a href="#Security-and-Human-Behavior" class="headerlink" title="Security and Human Behavior"></a>Security and Human Behavior</h2><h3 id="Information-Security"><a href="#Information-Security" class="headerlink" title="Information Security"></a>Information Security</h3><blockquote>
<p><strong>Digital Security</strong>: E.g. Files and web-access to servers</p>
<p><strong>Physical Security</strong>: Files can be printed and stored on USB storage device and servers can be in a locked room</p>
</blockquote>
<h3 id="Availability-further-definitions"><a href="#Availability-further-definitions" class="headerlink" title="Availability - further definitions"></a>Availability - further definitions</h3><blockquote>
<p><strong>Availbility</strong> is “the property of a system or a system resource being uable/ upon demand”</p>
<p>If availability is a requirement, <strong>an unusable system cannot be</strong> <strong>regarded as secure</strong></p>
</blockquote>
<h3 id="Usability"><a href="#Usability" class="headerlink" title="Usability"></a>Usability</h3><blockquote>
<p>Considering what a person (a ‘user’) wants to achieve (their ‘primary task’ toward an <em>outcome</em>) provides an approximation of the <em>context of use</em></p>
</blockquote>
<h2 id="Risk-Analysis-and-Risk-Perception"><a href="#Risk-Analysis-and-Risk-Perception" class="headerlink" title="Risk Analysis and Risk Perception"></a>Risk Analysis and Risk Perception</h2><h3 id="Security-Theatre"><a href="#Security-Theatre" class="headerlink" title="Security Theatre"></a>Security Theatre</h3><blockquote>
<p>Aim of security measures is not always to increase <em>actual</em> security</p>
<p><strong>Security Theatre</strong>: When the purpose of a security measure is to increase <em>perceived</em>, rather than actual, security</p>
</blockquote>
<h1 id="Lecture-2-1"><a href="#Lecture-2-1" class="headerlink" title="Lecture 2-1"></a>Lecture 2-1</h1><h2 id="Security-Mechanism-1"><a href="#Security-Mechanism-1" class="headerlink" title="Security Mechanism"></a>Security Mechanism</h2><blockquote>
<p><strong>Security mechanism</strong>: Technical mechanism used to ensure that the security policy is not violated by an adversary <u>operating within the threat model</u></p>
</blockquote>
<p>Could be <strong>software, hardware, cryptography, or peoples and procedures</strong> — this is why we’ll learn about all of these!</p>
<h2 id="Design-Principles"><a href="#Design-Principles" class="headerlink" title="Design Principles"></a>Design Principles</h2><h3 id="Least-privilege"><a href="#Least-privilege" class="headerlink" title="Least privilege"></a><strong>Least privilege</strong></h3><blockquote>
<p>The <strong>principle</strong> of <strong>least privilege</strong> works by allowing only enough access to perform the required job. In an IT environment, adhering to the <strong>principle</strong> of <strong>least privilege</strong> reduces the risk of attackers gaining access to critical systems or  sensitive data by compromising a low-level user account, device, or  application.</p>
</blockquote>
<h3 id="Separation-of-responsibilities"><a href="#Separation-of-responsibilities" class="headerlink" title="Separation of responsibilities"></a><strong>Separation of responsibilities</strong></h3><blockquote>
<p>E.g. For the system maintenance, there will be database admin, antivirus manager, and front-end engineer. </p>
<p>Everyone or every section of the system takes responsibility</p>
</blockquote>
<h3 id="Complete-mediation"><a href="#Complete-mediation" class="headerlink" title="Complete mediation"></a><strong>Complete mediation</strong></h3><blockquote>
<p>The <strong>principle</strong> of <strong>complete mediation</strong> requires that all accesses to objects be checked to ensure that they  are allowed. Whenever a subject attempts to read an object, the  operating system should <strong>mediate</strong> the action.</p>
</blockquote>
<h3 id="Fail-safe-default"><a href="#Fail-safe-default" class="headerlink" title="Fail-safe default"></a><strong>Fail-safe default</strong></h3><blockquote>
<p>The <strong>principle</strong> of <strong>fail</strong>-<strong>safe defaults</strong> states that, unless a subject is given explicit access to an object, it should be denied access to that object. This <strong>principle</strong> requires that the <strong>default</strong> access to an object is none.</p>
</blockquote>
<h3 id="Defence-in-Depth"><a href="#Defence-in-Depth" class="headerlink" title="Defence in Depth"></a><strong>Defence in Depth</strong></h3><blockquote>
<p><strong>Defense in depth</strong> defined. <strong>Defense in Depth</strong> (DiD) is an approach to cybersecurity in which a series of defensive  mechanisms are layered in order to protect valuable data and  information. If one mechanism fails, another steps up immediately to  thwart an attack.</p>
</blockquote>
<h3 id="Open-Design"><a href="#Open-Design" class="headerlink" title="Open Design"></a>Open Design</h3><blockquote>
<p>The <strong>principle</strong> of <strong>open design</strong> states that the security of a mechanism should not depend on the secrecy of its <strong>design</strong> or implementation. Designers and implementers of a program must not depend on secrecy of the details of their <strong>design</strong> and implementation to ensure security.</p>
</blockquote>
<h3 id="Psychological-Acceptability"><a href="#Psychological-Acceptability" class="headerlink" title="Psychological Acceptability"></a>Psychological Acceptability</h3><blockquote>
<p>The <strong>principle</strong> of <strong>psychological acceptability</strong> states that security mechanisms should not make the resource more  difficult to access than if the security mechanisms were not present.  Configuring and executing a program should be as easy and as intuitive  as possible, and any output should be clear, direct, and useful.</p>
</blockquote>
<h3 id="Economy-of-Mechanisms"><a href="#Economy-of-Mechanisms" class="headerlink" title="Economy of Mechanisms"></a>Economy of Mechanisms</h3><blockquote>
<p>KISS Principle: Keep it simple, stupid!</p>
<p>The <strong>principle</strong> of <strong>economy of mechanism</strong> states that security <strong>mechanisms</strong> should be as simple as possible. If a <strong>design</strong> and implementation are simple, fewer possibilities exist for errors.  The checking and testing process is less complex, because fewer  components and cases need to be tested.</p>
</blockquote>
<h3 id="Privacy-Promotion"><a href="#Privacy-Promotion" class="headerlink" title="Privacy Promotion"></a>Privacy Promotion</h3><blockquote>
<p>Don’t collect more data than strictly necessary</p>
</blockquote>
<h2 id="Fundamentals-of-Computer-Architecture-Design"><a href="#Fundamentals-of-Computer-Architecture-Design" class="headerlink" title="Fundamentals of Computer Architecture Design"></a>Fundamentals of Computer Architecture Design</h2><ul>
<li>Code is data</li>
<li>Layers of abstraction</li>
<li>Moore’s law</li>
<li>Halting problem</li>
</ul>
<h3 id="von-Neumann-Computer-Architecture"><a href="#von-Neumann-Computer-Architecture" class="headerlink" title="von Neumann Computer Architecture"></a>von Neumann Computer Architecture</h3><ul>
<li>von Neumann computer architecture does not distinguish between instructions for computer programs and data</li>
<li>Consequently, <strong>Code is data</strong><ul>
<li>Enables great flexibility in reprogramming computers</li>
<li>Programs can be costlessly reproduced, not just data</li>
</ul>
</li>
<li>There are unfortunate security implications</li>
</ul>
<h3 id="Layers-of-Abstraction"><a href="#Layers-of-Abstraction" class="headerlink" title="Layers of Abstraction"></a>Layers of Abstraction</h3><ul>
<li><p><strong>Abstraction:</strong> specifying meaning and behaviour of software while hiding implementation details</p>
</li>
<li><p><strong>Modular code</strong> exploits abstraction and enables composition and reuse</p>
</li>
<li><p>Abstraction and code modularity enables rapid software development (which has in turn led to a rapid rise in software complexity)</p>
</li>
<li><p>Unlike for mechanical engineering, in software engineering there is no practical limit to the potential combinations of code</p>
</li>
</ul>
<h3 id="Moore’s-Law"><a href="#Moore’s-Law" class="headerlink" title="Moore’s Law"></a>Moore’s Law</h3><ul>
<li><p>Intel founder Gordon Moore noticed in 1965 that integrated circuit density had been doubling since the 1950s</p>
</li>
<li><p>Moore’s Law: computer performance roughly doubles every 18-24 months</p>
</li>
</ul>
<h3 id="Halting-Problem"><a href="#Halting-Problem" class="headerlink" title="Halting Problem"></a>Halting Problem</h3><ul>
<li>In 1936, Alan Turing proved that it is impossible to write a general- purpose program that can determine whether another program will stop</li>
<li>Can be generalised: anything sufficiently interesting cannot be determined about a program</li>
<li>Implication: Security can never be solved!</li>
</ul>
<h1 id="Lecture-2-2"><a href="#Lecture-2-2" class="headerlink" title="Lecture 2-2"></a>Lecture 2-2</h1><h2 id="How-does-the-Internet-work"><a href="#How-does-the-Internet-work" class="headerlink" title="How does the Internet work?"></a>How does the Internet work?</h2><ul>
<li><a href="http://me.bob.com/hi.html">http://me.bob.com/hi.html</a><ul>
<li><code>http:</code>: protocol specifier</li>
<li><code>me.bob.com</code>: domain name</li>
<li><code>hi.html</code>: page location</li>
</ul>
</li>
</ul>
<h3 id="Step1-find-content-host"><a href="#Step1-find-content-host" class="headerlink" title="Step1: find content host"></a>Step1: find content host</h3><p>Goal: get <strong>IP address</strong> for <code>domain name</code> </p>
<ol>
<li>Find root Name Server</li>
<li>Find <code>.com</code> Name Server</li>
<li>Send ip(.com NS)</li>
<li>Get ip(bob.com NS) </li>
<li>Find bob.com NS</li>
<li>Send ip(bob.com NS)</li>
<li>Get ip(me.bob.com NS)</li>
<li>Find me.bob.com NS</li>
<li>Send ip(me.bob.com NS)</li>
<li>Get ip(me.bob.com)</li>
<li>Send back to the browser</li>
</ol>
<h3 id="Step-2-request-content"><a href="#Step-2-request-content" class="headerlink" title="Step 2: request content"></a>Step 2: request content</h3><ul>
<li><p>Where is the Internet?</p>
<ul>
<li>“the Internet is […] a series of tubes” (Senator Ted Stevens)</li>
<li><strong>Leased Lines</strong><ul>
<li>pros<ul>
<li>incredibly fast</li>
<li>reliable</li>
<li>secure</li>
</ul>
</li>
<li>cons<ul>
<li>Incredibly expensive</li>
</ul>
</li>
</ul>
</li>
<li>Internet Backbone</li>
</ul>
</li>
<li><p><strong>q</strong>: how does your router pick another router to ask?</p>
<p><strong>a</strong>: fascinating topic! autonomous systems (ASes), BGP, etc.</p>
</li>
<li><p><strong>q</strong>: how do you actually find these name servers? </p>
<p><strong>a</strong>: the magic of <strong>routing</strong>!</p>
</li>
<li><p><strong>q</strong>: what information are these routers sending? </p>
<p><strong>a</strong>: <strong>packets</strong>.</p>
</li>
<li><p><strong>q</strong>: could requests just go around in a circle?</p>
<p><strong>a</strong>: no! packets contain information on when to give up. Time to live (TTL): how many hops before dying?</p>
<p>(decremented by each router; also used for DNS records)</p>
</li>
<li><p>Proxy Server and VPNs</p>
<ul>
<li>pros<ul>
<li>get around firewalls </li>
<li>borrow access credentials</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Step3-Receive-Content"><a href="#Step3-Receive-Content" class="headerlink" title="Step3: Receive Content"></a>Step3: Receive Content</h3><ul>
<li>Content at hi.html is split into packets</li>
<li>Anyone can read the web traffic</li>
</ul>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ol>
<li>goal: get Alice to that website!</li>
<li>get IP address for me.bob.com (“domain name resolution”)</li>
<li>send GET request to IP address (routing via the internet backbone)</li>
<li>wait for response from IP address, then render hi.html and enjoy</li>
</ol>
<h2 id="What-Webpages-are-Made-Of"><a href="#What-Webpages-are-Made-Of" class="headerlink" title="What Webpages are Made Of"></a>What Webpages are Made Of</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>Markup language</li>
<li>HTML5 added interactive components:<ul>
<li>Canvas </li>
<li>Audio</li>
<li>Video</li>
</ul>
</li>
</ul>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul>
<li>Style language</li>
<li>Built to separate content from style</li>
<li>CSS3 — built in tandem with HTML5</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>Scripting language (similar to Python) • Server side (NodeJS)</li>
<li>Client side</li>
<li>Stateless</li>
</ul>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><ul>
<li>Used to store state on user’s machine</li>
<li>Name, value, attributes: • expiration date</li>
<li>hostname valid for</li>
<li>Secure (?)<ul>
<li>only over HTTPS </li>
<li>HTTPOnly (?)</li>
<li>not over JavaScript</li>
</ul>
</li>
</ul>
<h1 id="Lecture-3-1"><a href="#Lecture-3-1" class="headerlink" title="Lecture 3-1"></a>Lecture 3-1</h1><h2 id="Web-Architecture"><a href="#Web-Architecture" class="headerlink" title="Web Architecture"></a>Web Architecture</h2><blockquote>
<p>Websites are programs: HTML + CSS + JSS + Plugins</p>
</blockquote>
<ul>
<li>Partially executed by the client (HTML, JavaScript, plugins, etc.)</li>
<li>Partially executed by the server (PHP, Ruby, SQL, etc.)</li>
</ul>
<h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><p>It serves <strong>Static Content (HTML + CSS pages)</strong></p>
<p>And it also generates <strong>Dynamic Content:</strong></p>
<ul>
<li>CGI (Conmmon Gateway Interface): PHP, Python, etc</li>
<li>Web server modules: Rails, etc</li>
<li>Database Backend: SQL</li>
</ul>
<h2 id="Web-Cookies"><a href="#Web-Cookies" class="headerlink" title="Web Cookies"></a>Web Cookies</h2><p>The web server provides a <strong>token</strong> in its response that looks like:</p>
<p>Set-Cookie:<code>&lt;cookie-name&gt;=&lt;cookie-value&gt;</code></p>
<p>This is then <strong>attached to every future request</strong> sent to the server</p>
<h3 id="Kinds-of-cookies"><a href="#Kinds-of-cookies" class="headerlink" title="Kinds of cookies:"></a>Kinds of cookies:</h3><ul>
<li>Session cookies<ul>
<li><strong>Deleted</strong> when the user close the browser</li>
<li><strong>Expiration property is not set</strong></li>
</ul>
</li>
<li>Persistent cookies<ul>
<li>A <strong>persistent cookie</strong> is a data file capable of providing websites with user preferences, settings and information for future visits.</li>
<li>Are saved until some server-defined expiration</li>
</ul>
</li>
</ul>
<h2 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>Same-origin policy</strong>: script can read properties of documents only from the same server, protocol, and port</p>
<p>But, same-origin policy does not apply to scripts loaded from arbitrary site, so</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.example.com/myscript.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>runs as if it were loaded from the site that provided the page!</p>
<p>Server can also explicitly tell browser other domains that are allowed using Access-Control-Allow-Origin header</p>
<h2 id="HTML-Injection"><a href="#HTML-Injection" class="headerlink" title="HTML Injection"></a>HTML Injection</h2><p>Many interactive web applications echo user input:</p>
<ul>
<li>Search queries</li>
</ul>
<p><strong>What if user input contains HTML markup tags?</strong></p>
<p><strong>Similar story as with SQL injection</strong>: if the server doesn’t sanitise and encode it, markup is rendered by the web browser as it is provided by any user of the website</p>
<h2 id="Cross-Site-Scripting"><a href="#Cross-Site-Scripting" class="headerlink" title="Cross Site Scripting"></a>Cross Site Scripting</h2><p>A vulnerability that allows an <strong>attacker</strong> to <strong>run</strong> <strong>JavaScript</strong> on a victim webpage</p>
<h3 id="Type-of-XSS"><a href="#Type-of-XSS" class="headerlink" title="Type of XSS"></a>Type of XSS</h3><ul>
<li>Methods for injecting malicious code:<ul>
<li>Reflected XSS<ul>
<li>the attack script is reflected back to the user as part of a page from the victim site</li>
</ul>
</li>
<li>Persistant/Stored XSS<ul>
<li>the attacker stores the malicious code in a resource managed by the web application, such as a database</li>
</ul>
</li>
<li>Others, such as DOM-based attackers</li>
</ul>
</li>
</ul>
<h3 id="Reflected-XSS"><a href="#Reflected-XSS" class="headerlink" title="Reflected XSS"></a>Reflected XSS</h3><p>A <strong>reflected XSS</strong> (or also called a non-persistent <strong>XSS</strong> attack) is a specific type of <strong>XSS</strong> whose malicious script bounces off of another website to the victim’s  browser. It is passed in the query, typically, in the URL. It makes  exploitation as easy as tricking a user to <strong>click on a link.</strong></p>
<ul>
<li>E.g.<ul>
<li>PayPal 2006</li>
<li>Attackers contacted users via email and fooled them into accessing a particular URL hosted on the legitimate PayPal website.</li>
<li>Injected code redirected PayPal visitors to a page warning users their accounts had been compromised.</li>
<li>Victims were then redirected to a phishing site and prompted to enter sensitive financial data.</li>
</ul>
</li>
</ul>
<h3 id="Persistant-XSS"><a href="#Persistant-XSS" class="headerlink" title="Persistant XSS"></a>Persistant XSS</h3><p>XSS attacks enable attackers to <a href="https://en.wikipedia.org/wiki/Code_injection">inject</a> <a href="https://en.wikipedia.org/wiki/Client-side_script">client-side scripts</a> into <a href="https://en.wikipedia.org/wiki/Web_page">web pages</a> viewed by other users. A cross-site scripting vulnerability may be used by attackers to bypass <a href="https://en.wikipedia.org/wiki/Access_control">access controls</a> such as the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a>.</p>
<h3 id="Protecting-Against-XSS"><a href="#Protecting-Against-XSS" class="headerlink" title="Protecting Against XSS"></a>Protecting Against XSS</h3><ul>
<li><strong>Validates all</strong> headers, cookies, query strings, form fields, and hidden fields (i.e., all parameters) against a rigorous specification of what should be allowed.</li>
<li><strong>Do not attempt to identify active content and remove, filter, or sanitize it.</strong> There are too many types of active content and too many ways of encoding it to get around filters for such content.</li>
<li><strong>Adopt a ‘positive’ security policy that specifies what is allowed.</strong> ‘Negative’ or attack signature based policies are difficult to maintain and are likely to be incomplete.</li>
</ul>
<h4 id="Input-Data-Validation-Filtering"><a href="#Input-Data-Validation-Filtering" class="headerlink" title="Input Data Validation + Filtering"></a>Input Data Validation + Filtering</h4><ul>
<li>allow only what you expect</li>
<li>Remove/encode special characters</li>
</ul>
<h4 id="Output-filtering-encoding"><a href="#Output-filtering-encoding" class="headerlink" title="Output filtering/encoding"></a>Output filtering/encoding</h4><ul>
<li><p>Remove / encode HTML special chars </p>
<ul>
<li><code>&amp;lt; for &lt;, &amp;gt; for &gt;, &amp;quot for “</code></li>
</ul>
</li>
<li><p>Allow only safe commands (e.g., no <code>&lt;script&gt;</code>…) </p>
<ul>
<li>Caution: <code>filter evasion</code> tricks</li>
</ul>
</li>
<li><p>See XSS Cheat Sheet for filter evasion</p>
</li>
<li><p>E.g., if filter allows quoting (of <code>&lt;script&gt;</code> etc.), use malformed quoting: <code>&lt;IMG “””&gt;&lt;SCRIPT&gt;alert(“XSS”)</code></p>
</li>
</ul>
<h2 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF (Cross Site Request Forgery)"></a>CSRF (Cross Site Request Forgery)</h2><h3 id="Ineffective-Defense-POST"><a href="#Ineffective-Defense-POST" class="headerlink" title="Ineffective Defense: POST"></a>Ineffective Defense: POST</h3><ul>
<li>GET requests are easier to launch CSRF attacks, so some people naively switch to POSTs</li>
<li>This does not help</li>
</ul>
<h3 id="Ineffective-Defense-URL-Rewriting"><a href="#Ineffective-Defense-URL-Rewriting" class="headerlink" title="Ineffective Defense: URL Rewriting"></a>Ineffective Defense: URL Rewriting</h3><ul>
<li>dangerous to pass auth tokens in URLs (middleperson, logging issues)</li>
</ul>
<h3 id="Imperfect-Defense-Referer-Validation"><a href="#Imperfect-Defense-Referer-Validation" class="headerlink" title="Imperfect Defense: Referer Validation"></a>Imperfect Defense: Referer Validation</h3><ul>
<li>Does not work if Referer is missing</li>
<li>Referer Privacy Problems<ul>
<li>HTTP Referer may leak privacy-sensitive information</li>
<li>Common sources of blocking:<ul>
<li>Network stripping by the organisation</li>
<li>Network stripping by the local machine</li>
<li>Stripped by browser for HTTPS -&gt; HTTP transitions</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Denfense"><a href="#Denfense" class="headerlink" title="Denfense"></a>Denfense</h2><ul>
<li>Form keys</li>
<li>CSRF tokens<ul>
<li>Requests include a hard-to-guess secret<ul>
<li>Unguessability substitutes for unforgeability</li>
</ul>
</li>
</ul>
</li>
<li>Short cookies expiration date</li>
<li>Encourage users to log out</li>
</ul>
<h2 id="Double-Submitted-Cookies"><a href="#Double-Submitted-Cookies" class="headerlink" title="Double-Submitted Cookies"></a>Double-Submitted Cookies</h2><ul>
<li>Instead of writing separate nonce, re-use the session ID</li>
<li>When server replies to user, writes session ID to cookie as usual, plus writes into hidden form field</li>
<li>User posts form with value from hidden field and cookie, server verifies these are same</li>
<li>Why does this defence work?<ul>
<li>Attacker cannot reliably guess session ID (unless there is also an XSS vuln)</li>
</ul>
</li>
<li>Solution is completely stateless</li>
<li>Downside: passing session IDs in HTTP requests and responses is risky<ul>
<li>Solution: put hash(session ID) in hidden form field instead</li>
</ul>
</li>
</ul>
<h2 id="XSS-v-s-CSRF"><a href="#XSS-v-s-CSRF" class="headerlink" title="XSS v.s CSRF"></a>XSS v.s CSRF</h2><p><strong>XSS</strong></p>
<ul>
<li>Server-side vulnerability</li>
<li>Attacker injects a script into the trusted website Trusting browser executes attacker’s script</li>
</ul>
<p><strong>CSRF</strong></p>
<ul>
<li>Server-side vulnerability</li>
<li>Attacker gets trusted browser to issue requests Trusting website executes attacker’s requests</li>
</ul>
<h1 id="Lecture-3-2"><a href="#Lecture-3-2" class="headerlink" title="Lecture 3-2"></a>Lecture 3-2</h1><p>(Code Injection + Return-oriented Programming)</p>
<h2 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h2><blockquote>
<p>Attacker executes arbitrary code on <strong>Server</strong></p>
<p><strong>Not Sanitising</strong> user inputs/outputs</p>
</blockquote>
<h2 id="Unintended-Functionality"><a href="#Unintended-Functionality" class="headerlink" title="Unintended Functionality"></a>Unintended Functionality</h2><p>Security involves understanding both <strong>intended</strong> and <strong>unintended</strong> functionalities of the system.</p>
<blockquote>
<p>An <strong>exploit</strong> is a mechanism by which an attacker triggers some unintended functionality of the system (it is a blind spot for the developers)</p>
</blockquote>
<h2 id="What-makes-security-special"><a href="#What-makes-security-special" class="headerlink" title="What makes security special?"></a>What makes security special?</h2><p>These properties must hold even in the presence of a <strong>resourceful</strong> and <strong>strategic</strong> adversary</p>
<blockquote>
<p> <strong>Correctness:</strong> For a given input, a program should provide the correct output</p>
</blockquote>
<blockquote>
<p><strong>Safety</strong>: Well-formed programs cannot have bad (wrong or dangerous) outputs, no matter the input</p>
</blockquote>
<blockquote>
<p><strong>Robustness:</strong> Programs should be able to cope with errors in execution</p>
</blockquote>
<h2 id="Software-Vulnerability"><a href="#Software-Vulnerability" class="headerlink" title="Software Vulnerability"></a>Software Vulnerability</h2><ul>
<li><p>A <strong>software vulnerability</strong> is a bug in a program that allows a user capabilities that should be denied to them</p>
</li>
<li><p>One very common type of vulnerability is ones that violate <strong>control flow integrity</strong> (CFI)</p>
<p>Today we’ll look at <strong>SQL injections</strong> and <strong>buffer overflows</strong></p>
</li>
</ul>
<h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><ol>
<li><p><strong>Post malicious input to form</strong></p>
<ol>
<li><p>SQL Injection Based on 1=1 is Always True</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">txtUserId = getRequestString("UserId");</span><br><span class="line">txtSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">Users</span> <span class="keyword">WHERE</span> UserId = <span class="string">" + txtUserId;</span></span><br></pre></td></tr></table></figure>

<p>If users enter inputs like:  <strong>UserID</strong> <code>105 OR 1=1</code>, then the SQL statement will look like this:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">Users</span> <span class="keyword">WHERE</span> UserId = <span class="number">105</span> <span class="keyword">OR</span> <span class="number">1</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>The SQL above is valid and will return ALL rows from the “Users” table, since  <u><strong>OR 1=1</strong> is always TRUE.</u></p>
</li>
<li><p>SQL Injection Based on “”=”” is Always True</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uName = getRequestString("username");</span><br><span class="line">uPass = getRequestString("userpassword");</span><br><span class="line"></span><br><span class="line">sql = '<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">Users</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span> =<span class="string">"' + uName + '"</span> <span class="keyword">AND</span> Pass =<span class="string">"' + uPass + '"</span><span class="string">'</span></span><br></pre></td></tr></table></figure>

<p>A hacker might get access to user names and passwords in a database by  simply inserting “ OR “”=” into the user name or password text box:</p>
<p>User Name: <code>&quot; OR &quot;&quot;=&quot;</code></p>
<p>Password: <code>&quot; OR &quot;&quot;=&quot;</code></p>
<p>The code at the server will create a valid SQL statement like this:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">Users</span> <span class="keyword">WHERE</span> <span class="keyword">Name</span> =<span class="string">""</span> <span class="keyword">OR</span> <span class="string">""</span>=<span class="string">""</span> <span class="keyword">AND</span> Pass =<span class="string">""</span> <span class="keyword">OR</span> <span class="string">""</span>=<span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>The SQL above is valid and will return all rows from the “Users” table,  since <strong>OR “”=””</strong> is always TRUE.</p>
</li>
</ol>
</li>
<li><p><strong>Requests unintended SQL query</strong></p>
</li>
<li><p><strong>Returns unintended data to attacker</strong></p>
</li>
</ol>
<h2 id="SQL-Injection-Mitigations"><a href="#SQL-Injection-Mitigations" class="headerlink" title="SQL Injection Mitigations"></a>SQL Injection Mitigations</h2><p>Server-side applications generate SQL queries <strong>based on arbitrary user input</strong></p>
<p><strong>Solution? Don’t accept arbitrary user input!</strong></p>
<p><strong>Parameterised queries</strong>: pre-compiled queries that separate commands from input</p>
<p><strong>Input sanitisation</strong>: make sure only safe input is accepted What is unsafe?</p>
<ul>
<li>Single quote? Dashes? But these could be legitimate Sanitise on the client or the server<ul>
<li><strong>Use proper escaping/encoding?</strong></li>
</ul>
</li>
</ul>
<h2 id="Buffer-Overflows"><a href="#Buffer-Overflows" class="headerlink" title="Buffer Overflows"></a>Buffer Overflows</h2><blockquote>
<p> Program variables get allocated regions of physical memory in the form of <strong>buffers</strong></p>
<p>Buffer overflows happen when a program writes data beyond its allocated buffers</p>
<p>These are ubiquitous in systems-level languages (C/C++), made worse by the fact that many standard library functions make it easy to go beyond array bounds</p>
<p>String functions like strcpy() and strcat() write to the destination buffer until they encounter \0 in input, so the user providing the input (who can easily be the attacker!) controls how much gets written</p>
</blockquote>
<h3 id="Memory-Allocation-of-Programs"><a href="#Memory-Allocation-of-Programs" class="headerlink" title="Memory Allocation of Programs"></a>Memory Allocation of Programs</h3><p>The computer keeps track using a <strong>Stack</strong> when you make fucntion calls</p>
<h3 id="Call-Frame"><a href="#Call-Frame" class="headerlink" title="Call Frame"></a>Call Frame</h3><p>When a function is <strong>called</strong>:</p>
<ul>
<li>Allocate new <strong>frame</strong> for the callee</li>
<li>Caller pushes arguments and return address</li>
<li>Callee:<ul>
<li>pushes old <strong>frame pointer</strong> (fp): this points to <u>bottom of frame of currently executing function</u></li>
<li>Sets fp = sp (<strong>stack pointe</strong>r): this points to <u>top of stack</u></li>
</ul>
</li>
</ul>
<p>When a fucntion is <strong>returned</strong>:</p>
<ul>
<li>Callee pops local storage and sets <strong>sp = fp</strong></li>
<li>Callee pops <strong>fp</strong>(frame pointer)</li>
<li>Callee pops return address and returns to next instruction in caller frame </li>
</ul>
<h3 id="Smashing-the-Stack"><a href="#Smashing-the-Stack" class="headerlink" title="Smashing the Stack"></a>Smashing the Stack</h3><p>What happens if you overwrite a malicious value past the bounds of a local variable?</p>
<p>Could overwrite:</p>
<ul>
<li>another local variable<ul>
<li>What happens if you overwrite another local variable?</li>
<li><strong>It depends.</strong></li>
</ul>
</li>
<li>Saved fp<ul>
<li>What happens if you overwrite the saved fp?</li>
<li><strong>Probably terrible things!</strong><ul>
<li>When the function returns, the stack moves to an attacker-supplied address ⇒ complete control of execution</li>
<li>Even a single byte may be enough for this attack</li>
</ul>
</li>
</ul>
</li>
<li>return address<ul>
<li>What happens if you overwrite the return address?</li>
<li><strong>Terrible things!</strong></li>
<li>When the function returns, control is transferred to an attacker-supplied address ⇒ complete control of arbitrary code execution (re-direct to their own code)</li>
</ul>
</li>
<li>function argument</li>
<li>Deeper stack framess</li>
<li>exception control data</li>
</ul>
<h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2><blockquote>
<p> <strong>Shellcode</strong> is defined as a set of instructions injected and then executed by an exploited program. <strong>Shellcode</strong> is used to directly manipulate registers and the functionality of a exploited program.s</p>
</blockquote>
<p>Attacker ensures shellcode is somewhere in the stack before overwriting return address <strong>but they might not know exactly where it is</strong></p>
<h2 id="NOP-sleds"><a href="#NOP-sleds" class="headerlink" title="NOP sleds"></a>NOP sleds</h2><p>Instead, attacker can rely on the NOP (“no- op”) instruction to create something called a</p>
<p><strong>NOP sled</strong> (or a NOP slide)</p>
<p>As long as the attacker’s guess lands somewhere in this sequence of NOPs they can jump at the end to the start of the shellcode as desired</p>
<h2 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h2><ul>
<li>Data Execution Prevention</li>
<li>Maybe not everything needs to be executable?</li>
</ul>
<h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><ul>
<li>Randomisess address space</li>
<li>Now an attacker need to guess even more where they will land</li>
</ul>
<h2 id="Stack-Canaries"><a href="#Stack-Canaries" class="headerlink" title="Stack Canaries"></a>Stack Canaries</h2><ul>
<li>Write a random value to the end of the frame at the beginning of a function call.</li>
<li>Check that it is still there at the end.</li>
<li>If it’s not, then throw an error.</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>COMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo ERROR Render HTML failed</title>
    <url>/2020/04/01/Hexo-ERROR-Render-HTML-failed/</url>
    <content><![CDATA[<h1 id="ERROR-Render-HTML-failed"><a href="#ERROR-Render-HTML-failed" class="headerlink" title="ERROR-Render-HTML-failed"></a>ERROR-Render-HTML-failed</h1><p>Error reported when I entered <code>hexo g</code> to convert md file into HTML file</p>
<a id="more"></a>

<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 627 ms</span><br><span class="line">ERROR Render HTML failed: about/index.html</span><br><span class="line">TypeError: Cannot <span class="built_in">read</span> property <span class="string">'replace'</span> of null</span><br><span class="line">    at Hexo.externalLinkFilter (/Users/xiaqiulei/Documents/blog/node_modules/hexo/lib/plugins/filter/after_render/external_link.js:45:15)</span><br><span class="line">    at Hexo.tryCatcher (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/method.js:15:34)</span><br><span class="line">    at /Users/xiaqiulei/Documents/blog/node_modules/hexo/lib/extend/filter.js:60:50</span><br><span class="line">    at tryCatcher (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Object.gotValue (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/reduce.js:155:18)</span><br><span class="line">    at Object.gotAccum (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/reduce.js:144:25)</span><br><span class="line">    at Object.tryCatcher (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/promise.js:512:31)</span><br><span class="line">    at Promise._settlePromise (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/promise.js:569:18)</span><br><span class="line">    at Promise._settlePromiseCtx (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/promise.js:606:10)</span><br><span class="line">    at _drainQueueStep (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:142:12)</span><br><span class="line">    at _drainQueue (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:131:9)</span><br><span class="line">    at Async._drainQueues (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:147:5)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:17:14)</span><br><span class="line">    at processImmediate (internal/timers.js:439:21)</span><br><span class="line">ERROR Cannot <span class="built_in">read</span> property <span class="string">'replace'</span> of null</span><br><span class="line">TypeError: Cannot <span class="built_in">read</span> property <span class="string">'replace'</span> of null</span><br><span class="line">    at Hexo.externalLinkFilter (/Users/xiaqiulei/Documents/blog/node_modules/hexo/lib/plugins/filter/after_render/external_link.js:45:15)</span><br><span class="line">    at Hexo.tryCatcher (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/method.js:15:34)</span><br><span class="line">    at /Users/xiaqiulei/Documents/blog/node_modules/hexo/lib/extend/filter.js:60:50</span><br><span class="line">    at tryCatcher (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Object.gotValue (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/reduce.js:155:18)</span><br><span class="line">    at Object.gotAccum (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/reduce.js:144:25)</span><br><span class="line">    at Object.tryCatcher (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/promise.js:512:31)</span><br><span class="line">    at Promise._settlePromise (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/promise.js:569:18)</span><br><span class="line">    at Promise._settlePromiseCtx (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/promise.js:606:10)</span><br><span class="line">    at _drainQueueStep (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:142:12)</span><br><span class="line">    at _drainQueue (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:131:9)</span><br><span class="line">    at Async._drainQueues (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:147:5)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (/Users/xiaqiulei/Documents/blog/node_modules/bluebird/js/release/async.js:17:14)</span><br><span class="line">    at processImmediate (internal/timers.js:439:21)</span><br><span class="line">INFO  0 files generated <span class="keyword">in</span> 1.6 s</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li><p>Uninstall the extension of ‘Relative article recommendation’</p>
</li>
<li><p>Set the <code>enable</code> into false</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">'</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>ERROR</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-PDF</title>
    <url>/2020/04/13/Hexo-PDF-Test/</url>
    <content><![CDATA[<p><strong>Uploading PDF files without installing <code>hexo-pdf</code> extension.</strong></p>
<a id="more"></a>

<p>由于想上传一些PDF文件到博客上，查了下发现有一个<code>hexo-pdf</code>的插件可以很方便的用来潜入PDF文件。但是不知道是插件年久失修还是不支持最新Hexo版本，并不能达到预期效果。所以有了下面<del>简单粗暴</del>的方法。</p>
<h2 id="修改根目录下的-config-yml文件"><a href="#修改根目录下的-config-yml文件" class="headerlink" title="修改根目录下的_config.yml文件"></a>修改根目录下的_config.yml文件</h2><h3 id="将-config-yml中的post-asset-folder选项置为true"><a href="#将-config-yml中的post-asset-folder选项置为true" class="headerlink" title="将_config.yml中的post_asset_folder选项置为true"></a>将_config.yml中的post_asset_folder选项置为true</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>关于这个选项的功能说明如下:</p>
<blockquote>
<p>当您设置post_asset_folder为true参数后，在建立文件时，Hexo<br> 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p>
</blockquote>
<h3 id="然后新建一篇文章"><a href="#然后新建一篇文章" class="headerlink" title="然后新建一篇文章"></a>然后新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new &lt;article_name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于上一步已经将post_asset_folder选项设为了true<br>所以这一步新建文章时会创建一个md文件和一个同名的文件夹<br>为了方便叙述，我用test作为文件和文件夹名</p>
</blockquote>
<h3 id="编辑Markdown文件"><a href="#编辑Markdown文件" class="headerlink" title="编辑Markdown文件"></a>编辑Markdown文件</h3><blockquote>
<p>用Typora或者其他编辑器打开test.md<br>test.md文件中加入如下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"./Hello.pdf"</span> <span class="attr">type</span>=<span class="string">"application/pdf"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"877px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于这句代码简单的解释<br>data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文件夹</p>
</blockquote>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><br>

<object data="./Hello.pdf" type="application/pdf" width="100%" height="877px">
</object>
<br>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qappleh/article/details/80250492">前端预览PDF总结</a></p>
<p><a href="http://miracle778.site/pdf-test/pdf-test.html">hexo中插入pdf解决方法</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode做题记录</title>
    <url>/2020/04/23/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a><a href="https://leetcode-cn.com/problems/isomorphic-strings/">205.同构字符串</a></h1><p><u><strong>思路分析</strong></u></p>
<ul>
<li><p>我们可以利用一个 HashMap 来处理映射。对于 s 到 t 的映射，我们同时遍历 s 和 t ，假设当前遇到的字母分别是 c1 和 c2 。</p>
</li>
<li><p>如果 map[c1] 不存在，那么就将 c1 映射到 c2 ，即 map[c1] = c2。</p>
</li>
<li><p>如果 map[c1] 存在，那么就判断 map[c1] 是否等于 c2，也就是验证之前的映射和当前的字母是否相同。</p>
</li>
<li><p>对于这道题，我们只需要验证 s - &gt; t 和 t -&gt; s 两个方向即可。如果验证一个方向，是不可以的。</p>
</li>
<li><p>举个例子，s = ab, t = cc，如果单看 s -&gt; t ，那么 a -&gt; c, b -&gt; c 是没有问题的。</p>
</li>
<li><p>必须再验证 t -&gt; s，此时，c -&gt; a, c -&gt; b，一个字母对应了多个字母，所以不是同构的。代码的话，只需要调用两次上边的代码即可。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg 和 add 同构，就意味着下边的映射成立</span><br><span class="line">e -&gt; a</span><br><span class="line">g -&gt; d</span><br><span class="line">也就是将 egg 的 e 换成 a, g 换成 d, 就变成了 add</span><br><span class="line"></span><br><span class="line">同时倒过来也成立</span><br><span class="line">a -&gt; e</span><br><span class="line">d -&gt; g</span><br><span class="line">也就是将 add 的 a 换成 e, d 换成 g, 就变成了 egg</span><br><span class="line"></span><br><span class="line">foo 和 bar 不同构，原因就是映射不唯一</span><br><span class="line">o -&gt; a</span><br><span class="line">o -&gt; r</span><br><span class="line">其中 o 映射到了两个字母</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic1</span><span class="params">(String s,String t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isIsomorphicHelper(s,t) &amp;&amp; isIsomorphicHelper(t,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphicHelper</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> c2 = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c1))&#123;</span><br><span class="line">                map.put(c1,c2);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(c1)!=c2)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Quarantine in Shanghai</title>
    <url>/2020/04/07/Quarantine-in-Shanghai/</url>
    <content><![CDATA[<h1 id="隔离记录"><a href="#隔离记录" class="headerlink" title="隔离记录"></a>隔离记录</h1><a id="more"></a>

<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day1.JPG" alt="day1"></p>
<p>早上温度：36.9摄氏度</p>
<p>下午温度：36.1摄氏度</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day2.JPG" alt="day2"></p>
<p>早上温度：36.6摄氏度</p>
<p>下午温度：36.4摄氏度</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3 *"></a>Day 3 *</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day3.JPG" alt="day3"></p>
<p>早上温度：36.0摄氏度</p>
<p>下午温度：36.5摄氏度</p>
<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day4.JPG" alt="day4"></p>
<p>上午温度：36.0摄氏度</p>
<p>下午温度：36.5摄氏度</p>
<h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5 *"></a>Day 5 *</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day5.JPG" alt=""></p>
<p>上午温度：36.0摄氏度</p>
<p>下午温度：36.4摄氏度</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day6.JPG" alt=""></p>
<p>上午温度：36.5摄氏度</p>
<p>下午温度：36.9摄氏度</p>
<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7 *"></a>Day 7 *</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day7.JPG" alt=""></p>
<p>上午温度：36.4摄氏度</p>
<p>下午温度：36.7摄氏度</p>
<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day8.JPG" alt=""></p>
<p>上午温度：36.3摄氏度</p>
<p>下午温度：36.7摄氏度</p>
<h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9 *"></a>Day 9 *</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day9.JPG" alt=""></p>
<p>上午温度：36.3摄氏度</p>
<p>下午温度：36.6摄氏度</p>
<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10 *"></a>Day 10 *</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day10.JPG" alt=""></p>
<p>上午温度：36.2摄氏度</p>
<p>下午温度：36.7摄氏度</p>
<h2 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11 *"></a>Day 11 *</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day11.JPG" alt=""></p>
<p>上午温度：36.4摄氏度</p>
<p>下午温度：36.5摄氏度</p>
<h2 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day12.JPG" alt=""></p>
<p>上午温度：36.1摄氏度</p>
<p>下午温度：36.5摄氏度</p>
<h2 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day13.JPG" alt=""></p>
<p>上午温度：36.1摄氏度</p>
<p>下午温度：36.8摄氏度</p>
<h2 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h2><p><img src="https://raw.githubusercontent.com/yifanzhang13/yifanzhang13.github.io/master/images/QuarantinePics/day14.JPG" alt=""></p>
<p>上午温度：36.2摄氏度</p>
<p>下午温度：36.5摄氏度</p>
]]></content>
  </entry>
  <entry>
    <title>MachineLearning_Notes</title>
    <url>/2020/06/14/MachineLearning-Notes/</url>
    <content><![CDATA[<p>This is a study note for <a href="https://www.coursera.org/learn/machine-learning"><strong>Machine Learning_Andrew Ng</strong></a>:</p>
<p>It includes notes from Internet and my own notes.</p>
<a id="more"></a>

<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="What-is-machine-learning"><a href="#What-is-machine-learning" class="headerlink" title="What is machine learning?"></a>What is machine learning?</h3><p>There are 2 definitions:</p>
<ol>
<li><p><strong>Arthur Samuel</strong> described it as: “<strong>the field of study that gives computers  the ability to learn without being explicitly programmed</strong>.” This is an  older, informal definition.</p>
</li>
<li><p><strong>Tom Mitchell</strong> provides a more modern definition: “<strong>A computer program  is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as  measured by P, improves with experience E.</strong>“</p>
<p>Example: playing checkers.</p>
<p>E = the experience of playing many games of checkers</p>
<p>T = the task of playing checkers.</p>
<p>P = the probability that the program will win the next game.</p>
<p>In general, any machine learning problem can be assigned to one of two broad classifications:</p>
<p>Supervised learning and Unsupervised learning.</p>
</li>
</ol>
<h3 id="Supervied-Learning"><a href="#Supervied-Learning" class="headerlink" title="Supervied Learning"></a>Supervied Learning</h3><p>In supervised learning, we are <strong>given a data set</strong> and <strong>already know what our  correct output should look like</strong>, having the idea that there is a  relationship between the input and the output.</p>
<p>Supervised learning problems are categorized into “<strong>regression</strong>“ and “<strong>classification</strong>“  problems:</p>
<ol>
<li><p>In a regression problem, we are trying to predict results  within a <strong>continuous output</strong>, meaning that we are trying to <strong>map input  variables to some</strong> <strong>continuous function</strong>.</p>
</li>
<li><p>In a classification problem, we  are instead trying to predict results in a <strong>discrete output</strong>. In other  words, we are trying to <strong>map input variables into discrete categories</strong>. </p>
</li>
</ol>
<p><strong>Example 1:</strong></p>
<p>Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so  this is a regression problem.</p>
<p>We could turn this example into a  classification problem by instead making our output about whether the  house “sells for more or less than the asking price.” Here we are  classifying the houses based on price into two discrete categories.</p>
<p><strong>Example 2</strong>:</p>
<p>(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture</p>
<p>(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign. </p>
<h3 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h3><p>Unsupervised learning allows us to approach problems with <strong>little or no idea what our results should look like</strong>. We can <strong>derive structure from data</strong> where we  don’t necessarily know the effect of the variables.</p>
<p>We can derive this structure by <strong>clustering the data</strong> based on relationships among the variables in the data.</p>
<p>With unsupervised learning there is <strong>no feedback</strong> based on the prediction results.</p>
<p><strong>Example:</strong></p>
<p>Clustering: Take a collection of 1,000,000 different genes, and find a way to  automatically group these genes into groups that are somehow similar or  related by different variables, such as lifespan, location, roles, and  so on.</p>
<p>Non-clustering: The “Cocktail Party Algorithm”, allows you  to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a <a href="https://en.wikipedia.org/wiki/Cocktail_party_effect">cocktail party</a>).</p>
<h2 id="Model-and-Cost-Function"><a href="#Model-and-Cost-Function" class="headerlink" title="Model and Cost Function"></a>Model and Cost Function</h2><h3 id="Model-Representation"><a href="#Model-Representation" class="headerlink" title="Model Representation"></a>Model Representation</h3><p>![image-20200615170301978](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615170301978.png)</p>
<h3 id="Cost-Function-1-0"><a href="#Cost-Function-1-0" class="headerlink" title="Cost Function 1.0"></a>Cost Function 1.0</h3><p>![image-20200615172340058](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615172340058.png)</p>
<p>![image-20200615172530793](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615172530793.png)</p>
<h3 id="Cost-Function-1-1"><a href="#Cost-Function-1-1" class="headerlink" title="Cost Function 1.1"></a>Cost Function 1.1</h3><p>![image-20200615204145231](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615204145231.png)</p>
<p>![image-20200615204157751](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615204157751.png)</p>
<p>![image-20200615204236086](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615204236086.png)</p>
<h3 id="Cost-Function-1-2"><a href="#Cost-Function-1-2" class="headerlink" title="Cost Function 1.2"></a>Cost Function 1.2</h3><p>![image-20200615205454678](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615205454678.png)</p>
<p>![image-20200615205549667](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615205549667.png)</p>
<p>![image-20200615205601781](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615205601781.png)</p>
<h2 id="Parameter-Learning"><a href="#Parameter-Learning" class="headerlink" title="Parameter Learning"></a>Parameter Learning</h2><h3 id="Gradient-Descent-Algorithm-1-0"><a href="#Gradient-Descent-Algorithm-1-0" class="headerlink" title="Gradient Descent Algorithm 1.0"></a>Gradient Descent Algorithm 1.0</h3><p>![image-20200615225814617](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615225814617.png)</p>
<p>![image-20200615225826171](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200615225826171.png)</p>
<h3 id="Gradient-Descent-Algorithm-1-1"><a href="#Gradient-Descent-Algorithm-1-1" class="headerlink" title="Gradient Descent Algorithm 1.1"></a>Gradient Descent Algorithm 1.1</h3><p>![image-20200616095147861](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200616095147861.png)</p>
<p>![image-20200616095158666](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200616095158666.png)</p>
<p>![image-20200616095206864](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200616095206864.png)</p>
<h3 id="Gradient-Descent-Algorithm-1-2"><a href="#Gradient-Descent-Algorithm-1-2" class="headerlink" title="Gradient Descent Algorithm 1.2"></a>Gradient Descent Algorithm 1.2</h3><p>![image-20200616101447288](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200616101447288.png)</p>
<p>![image-20200616101544398](/Users/yifancheung/Library/Application Support/typora-user-images/image-20200616101544398.png)</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Usage Of Volatile In Java</title>
    <url>/2019/12/02/Usage-Of-Volatile-In-Java/</url>
    <content><![CDATA[<p>Volatile用在多线程，同步变量。 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A)</p>
<p>在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。</p>
<a id="more"></a>



<p>一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。以下例子展现了volatile的作用：</p>
<p>public class StoppableTask extends Thread {  </p>
<p>  private volatile boolean pleaseStop;  </p>
<p>  public void run() {  </p>
<pre><code>while (!pleaseStop) {  

 // do some stuff...  

}  </code></pre><p> }  </p>
<p>  public void tellMeToStop() {  </p>
<p>   pleaseStop = true;  </p>
<p>  }  </p>
<p>}  </p>
<p>假如pleaseStop没有被声明为volatile，线程执行run的时候检查的是自己的副本，就不能及时得知其他线程已经调用tellMeToStop()修改了pleaseStop的值。</p>
<p>Volatile一般情况下不能代替sychronized，因为volatile不能保证操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。如果配合Java 5增加的atomic wrapper classes，对它们的increase之类的操作就不需要sychronized。</p>
<p>Reference：<br><a href="http://www.javamex.com/tutorials/synchronization_volatile.shtml">http://www.javamex.com/tutorials/synchronization_volatile.shtml</a><br><a href="http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml">http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">http://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a><br>恐怕比较一下volatile和synchronized的不同是最容易解释清楚的。volatile是变量修饰符，而synchronized则作用于一段代码或方法；看如下三句get代码：</p>
<p>int i1;<br>int geti1() {return i1;}<br>volatile int i2;<br>int geti2()<br>{return i2;}<br>int i3;<br>synchronized int geti3() {return i3;}<br>　　geti1()  </p>
<p>得到存储在当前线程中i1的数值。多个线程有多个i1变量拷贝，而且这些i1之间可以互不相同。换句话说，另一个线程可能已经改变了它线程内的i1值，而这个值可以和当前线程中的i1值不相同。事实上，Java有个思想叫“主”内存区域，这里存放了变量目前的“准确值”。每个线程可以有它自己的变量拷贝，而这个变量拷贝值可以和“主”内存区域里存放的不同。因此实际上存在一种可能：“主”内存区域里的i1值是1，线程1里的i1值是2，线程2里的i1值是3——这在线程1和线程2都改变了它们各自的i1值，而且这个改变还没来得及传递给“主”内存区域或其他线程时就会发生。<br>　　而 geti2()得到的是“主”内存区域的i2数值。用volatile修饰后的变量不允许有不同于“主”内存区域的变量拷贝。换句话说，一个变量经 volatile修饰后在所有线程中必须是同步的；任何线程中改变了它的值，所有其他线程立即获取到了相同的值。理所当然的，volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。<br>　　既然volatile关键字已经实现了线程间数据同步，又要 synchronized干什么呢？呵呵，它们之间有两点不同。首先，synchronized获得并释放监视器——如果两个线程使用了同一个对象锁，监视器能强制保证代码块同时只被一个线程所执行——这是众所周知的事实。但是，synchronized也同步内存：事实上，synchronized在“ 主”内存区域同步整个线程的内存。因此，执行geti3()方法做了如下几步：</p>
<pre><code>线程请求获得监视this对象的对象锁（假设未被锁，否则线程等待直到锁释放）
线程内存的数据被消除，从“主”内存区域中读入（Java虚拟机能优化此步。。。[后面的不知道怎么表达,汗]）
代码块被执行
对于变量的任何改变现在可以安全地写到“主”内存区域中（不过geti3()方法不会改变变量值）
线程释放监视this对象的对象锁
　　因此volatile只是在线程内存和“主”内存间同步某个变量的值，而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源。
volatile关键字相信了解Java多线程的读者都很清楚它的作用。volatile关键字用于声明简单类型变量，如int、float、 boolean等数据类型。如果这些简单数据类型声明为volatile，对它们的操作就会变成原子级别的。但这有一定的限制。例如，下面的例子中的n就不是原子级别的：</code></pre><p>package  mythread;  </p>
<p>public   class  JoinThread  extends  Thread<br>{<br>     public   static volatile int  n  =   0 ;<br>    public   void  run()<br>    {<br>         for  ( int  i  =   0 ; i  &lt;   10 ; i ++ )<br>             try<br>        {<br>                n  =  n  +   1 ;<br>                sleep( 3 );  //  为了使运行结果更随机，延迟3毫秒   </p>
<pre><code>        }  
         catch  (Exception e)  
        {  
        }  
}  

 public   static   void  main(String[] args)  throws  Exception  
{  

    Thread threads[]  =   new  Thread[ 100 ];  
     for  ( int  i  =   0 ; i  &lt;  threads.length; i ++ )  
         //  建立100个线程   
        threads[i]  =   new  JoinThread();  
     for  ( int  i  =   0 ; i  &lt;  threads.length; i ++ )  
         //  运行刚才建立的100个线程   
        threads[i].start();  
     for  ( int  i  =   0 ; i  &lt;  threads.length; i ++ )  
         //  100个线程都执行完后继续   
        threads[i].join();  
    System.out.println( &quot; n= &quot;   +  JoinThread.n);  
}  </code></pre><p>}   </p>
<p>如果对n的操作是原子级别的，最后输出的结果应该为n=1000，而在执行上面积代码时，很多时侯输出的n都小于1000，这说明n=n+1不是原子级别的操作。原因是声明为volatile的简单变量如果当前值由该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：</p>
<p>n  =  n  +   1 ;<br>n ++ ; </p>
<p>如果要想使这种情况变成原子操作，需要使用synchronized关键字，如上的代码可以改成如下的形式：</p>
<p>package  mythread;  </p>
<p>public   class  JoinThread  extends  Thread<br>{<br>     public   static int  n  =   0 ;  </p>
<pre><code> public static   synchronized   void  inc()  
{  
    n ++ ;  
}  
 public   void  run()  
{  
     for  ( int  i  =   0 ; i  &lt;   10 ; i ++ )  
         try   
        {  
            inc();  //  n = n + 1 改成了 inc();   
            sleep( 3 );  //  为了使运行结果更随机，延迟3毫秒   

        }  
         catch  (Exception e)  
        {  
        }  
}  

 public   static   void  main(String[] args)  throws  Exception  
{  

    Thread threads[]  =   new  Thread[ 100 ];  
     for  ( int  i  =   0 ; i  &lt;  threads.length; i ++ )  
         //  建立100个线程   
        threads[i]  =   new  JoinThread();  
     for  ( int  i  =   0 ; i  &lt;  threads.length; i ++ )  
         //  运行刚才建立的100个线程   
        threads[i].start();  
     for  ( int  i  =   0 ; i  &lt;  threads.length; i ++ )  
         //  100个线程都执行完后继续   
        threads[i].join();  
    System.out.println( &quot; n= &quot;   +  JoinThread.n);  
}  </code></pre><p>}   </p>
<p>上面的代码将n=n+1改成了inc()，其中inc方法使用了synchronized关键字进行方法同步。因此，在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原来操作，当变量的值由自身的上一个决定时，如n=n+1、n++ 等，volatile关键字将失效，只有当变量的值和自身上一个值无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Standford_CS231n_notes</title>
    <url>/2020/08/04/Standford-CS231n-notes/</url>
    <content><![CDATA[<h1 id="Standford-CS231n-Convolutional-Netwroks-for-Visual-Recognition"><a href="#Standford-CS231n-Convolutional-Netwroks-for-Visual-Recognition" class="headerlink" title="Standford CS231n: Convolutional Netwroks for Visual Recognition"></a><a href="http://cs231n.stanford.edu/syllabus.html">Standford CS231n: Convolutional Netwroks for Visual Recognition</a></h1><p>it includes my own notes and notes on the internet for this lecture.</p>
<a id="more"></a>

<h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><blockquote>
<p>Description: </p>
<p><strong>Course Introduction</strong><br>Computer vision overview<br>Historical context<br>Course logistics    </p>
</blockquote>
<h2 id="Lecture-2"><a href="#Lecture-2" class="headerlink" title="Lecture 2"></a>Lecture 2</h2><blockquote>
<p>​    Description:</p>
<p><strong>Image Classification</strong> </p>
<p>The data-driven approach   </p>
<p>K-nearest neighbor</p>
<p>Linear classification I    </p>
</blockquote>
<h3 id="Python-Numpy-Tutorial-with-Jupyter-and-Colab"><a href="#Python-Numpy-Tutorial-with-Jupyter-and-Colab" class="headerlink" title="Python Numpy Tutorial (with Jupyter and Colab)"></a><a href="https://cs231n.github.io/python-numpy-tutorial/#basic-data-types">Python Numpy Tutorial (with Jupyter and Colab)</a></h3><p>Python does not have unary increment (<code>x++</code>) or decrement (<code>x--</code>) operators.</p>
<ul>
<li><p>String</p>
<ul>
<li><pre><code class="python">hello = <span class="string">'hello'</span>   <span class="comment"># String literals can use single quotes</span>
world = <span class="string">"world"</span>   <span class="comment"># or double quotes; it does not matter</span>
print(hello, len(hello))
hw = hello + <span class="string">' '</span> + world  <span class="comment"># String concatenation</span>
hw12 = <span class="string">'{} {} {}'</span>.format(hello, world, <span class="number">12</span>)  <span class="comment"># string formatting</span>
s = <span class="string">"hello"</span>
print(s.capitalize())  <span class="comment"># Capitalize a string</span>
print(s.upper())       <span class="comment"># Convert a string to uppercase; prints "HELLO"</span>
print(s.rjust(<span class="number">7</span>))      <span class="comment"># Right-justify a string, padding with spaces</span>
print(s.center(<span class="number">7</span>))     <span class="comment"># Center a string, padding with spaces</span>
print(s.replace(<span class="string">'l'</span>, <span class="string">'(ell)'</span>))  <span class="comment"># Replace all instances of one substring with another</span>
print(<span class="string">'  world '</span>.strip())  <span class="comment"># Strip leading and trailing whitespace</span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Container</span><br><span class="line"></span><br><span class="line">  - **List**</span><br><span class="line"></span><br><span class="line">    - A list is the Python **equivalent of an array**, but is **resizeable** and can contain elements of **different types**</span><br><span class="line"></span><br><span class="line">      ```python</span><br><span class="line">      xs = [3, 1, 2]    # Create a list</span><br><span class="line">      print(xs, xs[2])  # Prints &quot;[3, 1, 2] 2&quot;</span><br><span class="line">      print(xs[-1])     # Negative indices count from the end of the list; prints &quot;2&quot;</span><br><span class="line">      xs[2] = &apos;foo&apos;     # Lists can contain elements of different types</span><br><span class="line">      print(xs)         # Prints &quot;[3, 1, &apos;foo&apos;]&quot;</span><br><span class="line">      xs.append(&apos;bar&apos;)  # Add a new element to the end of the list</span><br><span class="line">      print(xs)         # Prints &quot;[3, 1, &apos;foo&apos;, &apos;bar&apos;]&quot;</span><br><span class="line">      x = xs.pop()      # Remove and return the last element of the list</span><br><span class="line">      print(x, xs)      # Prints &quot;bar [3, 1, &apos;foo&apos;]&quot;</span><br></pre></td></tr></table></figure>

- **Slicing:** In addition to accessing list elements one at a time, Python provides concise syntax to access sublists; this <span class="keyword">is</span> known <span class="keyword">as</span> *slicing*:

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = list(range(<span class="number">5</span>))     <span class="comment"># range is a built-in function that creates a list of integers</span></span><br><span class="line">print(nums)               <span class="comment"># Prints "[0, 1, 2, 3, 4]"</span></span><br><span class="line">print(nums[<span class="number">2</span>:<span class="number">4</span>])          <span class="comment"># Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"</span></span><br><span class="line">print(nums[<span class="number">2</span>:])           <span class="comment"># Get a slice from index 2 to the end; prints "[2, 3, 4]"</span></span><br><span class="line">print(nums[:<span class="number">2</span>])           <span class="comment"># Get a slice from the start to index 2 (exclusive); prints "[0, 1]"</span></span><br><span class="line">print(nums[:])            <span class="comment"># Get a slice of the whole list; prints "[0, 1, 2, 3, 4]"</span></span><br><span class="line">print(nums[:<span class="number">-1</span>])          <span class="comment"># Slice indices can be negative; prints "[0, 1, 2, 3]"</span></span><br><span class="line">nums[<span class="number">2</span>:<span class="number">4</span>] = [<span class="number">8</span>, <span class="number">9</span>]        <span class="comment"># Assign a new sublist to a slice</span></span><br><span class="line">print(nums)               <span class="comment"># Prints "[0, 1, 8, 9, 4]"</span></span><br></pre></td></tr></table></figure>

- **Loops:** You can loop over the elements of a list like this:

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'monkey'</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    print(animal)</span><br><span class="line"><span class="comment"># Prints "cat", "dog", "monkey", each on its own line.</span></span><br></pre></td></tr></table></figure>

  If you want access to the index of each element within the body of a loop, use the built-<span class="keyword">in</span> `enumerate` function:

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'monkey'</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> enumerate(animals):</span><br><span class="line">    print(<span class="string">'#%d: %s'</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints "#1: cat", "#2: dog", "#3: monkey", each on its own line</span></span><br></pre></td></tr></table></figure>

- **List comprehensions:** When programming, frequently we want to transform one type of data into another. As a simple example, consider the following code that computes square numbers:

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    squares.append(x ** <span class="number">2</span>)</span><br><span class="line">print(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

  You can make this code simpler using a **list comprehension**:

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line">print(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

  List comprehensions can also contain conditions:

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">even_squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(even_squares)  <span class="comment"># Prints "[0, 4, 16]"</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><h4 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h4><p>A dictionary stores (key, value) pairs, similar to a <code>Map</code> in Java or an object in Javascript. You can use it like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'cat'</span>: <span class="string">'cute'</span>, <span class="string">'dog'</span>: <span class="string">'furry'</span>&#125;  <span class="comment"># Create a new dictionary with some data</span></span><br><span class="line">print(d[<span class="string">'cat'</span>])       <span class="comment"># Get an entry from a dictionary; prints "cute"</span></span><br><span class="line">print(<span class="string">'cat'</span> <span class="keyword">in</span> d)     <span class="comment"># Check if a dictionary has a given key; prints "True"</span></span><br><span class="line">d[<span class="string">'fish'</span>] = <span class="string">'wet'</span>     <span class="comment"># Set an entry in a dictionary</span></span><br><span class="line">print(d[<span class="string">'fish'</span>])      <span class="comment"># Prints "wet"</span></span><br><span class="line"><span class="comment"># print(d['monkey'])  # KeyError: 'monkey' not a key of d</span></span><br><span class="line">print(d.get(<span class="string">'monkey'</span>, <span class="string">'N/A'</span>))  <span class="comment"># Get an element with a default; prints "N/A"</span></span><br><span class="line">print(d.get(<span class="string">'fish'</span>, <span class="string">'N/A'</span>))    <span class="comment"># Get an element with a default; prints "wet"</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">'fish'</span>]         <span class="comment"># 删除key fish</span></span><br><span class="line">print(d.get(<span class="string">'fish'</span>, <span class="string">'N/A'</span>)) <span class="comment"># "fish" is no longer a key; prints "N/A"</span></span><br></pre></td></tr></table></figure>

<p>You can find all you need to know about dictionaries <a href="https://docs.python.org/3.5/library/stdtypes.html#dict">in the documentation</a>.</p>
<p><strong>Loops:</strong> It is easy to iterate over the keys in a dictionary:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'person'</span>: <span class="number">2</span>, <span class="string">'cat'</span>: <span class="number">4</span>, <span class="string">'spider'</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> d:</span><br><span class="line">    legs = d[animal]</span><br><span class="line">    print(<span class="string">'A %s has %d legs'</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs"</span></span><br></pre></td></tr></table></figure>

<p>If you want access to keys and their corresponding values, use the <code>items</code> method:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'person'</span>: <span class="number">2</span>, <span class="string">'cat'</span>: <span class="number">4</span>, <span class="string">'spider'</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    print(<span class="string">'A %s has %d legs'</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs"</span></span><br></pre></td></tr></table></figure>

<p><strong>Dictionary comprehensions:</strong> These are similar to list comprehensions, but allow you to easily construct dictionaries. For example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">even_num_to_square = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">print(even_num_to_square)  <span class="comment"># Prints "&#123;0: 0, 2: 4, 4: 16&#125;"</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>A set is an <strong>unordered collection</strong> of <strong>distinct</strong> elements. As a simple example, consider the following:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = &#123;<span class="string">'cat'</span>, <span class="string">'dog'</span>&#125;</span><br><span class="line">print(<span class="string">'cat'</span> <span class="keyword">in</span> animals)   <span class="comment"># Check if an element is in a set; prints "True"</span></span><br><span class="line">print(<span class="string">'fish'</span> <span class="keyword">in</span> animals)  <span class="comment"># prints "False"</span></span><br><span class="line">animals.add(<span class="string">'fish'</span>)       <span class="comment"># Add an element to a set</span></span><br><span class="line">print(<span class="string">'fish'</span> <span class="keyword">in</span> animals)  <span class="comment"># Prints "True"</span></span><br><span class="line">print(len(animals))       <span class="comment"># Number of elements in a set; prints "3"</span></span><br><span class="line">animals.add(<span class="string">'cat'</span>)        <span class="comment"># Adding an element that is already in the set does nothing</span></span><br><span class="line">print(len(animals))       <span class="comment"># Prints "3"</span></span><br><span class="line">animals.remove(<span class="string">'cat'</span>)     <span class="comment"># Remove an element from a set</span></span><br><span class="line">print(len(animals))       <span class="comment"># Prints "2"</span></span><br></pre></td></tr></table></figure>

<p>As usual, everything you want to know about sets can be found <a href="https://docs.python.org/3.5/library/stdtypes.html#set">in the documentation</a>.</p>
<p><strong>Loops:</strong> Iterating over a set has the same syntax as iterating over a list; however since sets are unordered, you cannot make assumptions about the order in which you visit the elements of the set:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = &#123;<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> enumerate(animals):</span><br><span class="line">    print(<span class="string">'#%d: %s'</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints "#1: fish", "#2: dog", "#3: cat"</span></span><br></pre></td></tr></table></figure>

<p><strong>Set comprehensions:</strong> Like lists and dictionaries, we can easily construct sets using set comprehensions:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">nums = &#123;int(sqrt(x)) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">30</span>)&#125;</span><br><span class="line">print(nums)  <span class="comment"># Prints "&#123;0, 1, 2, 3, 4, 5&#125;"</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>A tuple is an (immutable) ordered list of values. A tuple is in many ways similar to a list; one of the most important differences is that <strong>tuples can be used as keys in dictionaries and as elements of sets, while lists cannot</strong>. Here is a trivial example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;(x, x + <span class="number">1</span>): x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;  <span class="comment"># Create a dictionary with tuple keys</span></span><br><span class="line">t = (<span class="number">5</span>, <span class="number">6</span>)        <span class="comment"># Create a tuple</span></span><br><span class="line">print(type(t))    <span class="comment"># Prints "&lt;class 'tuple'&gt;"</span></span><br><span class="line">print(d[t])       <span class="comment"># Prints "5"</span></span><br><span class="line">print(d[(<span class="number">1</span>, <span class="number">2</span>)])  <span class="comment"># Prints "1"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Class</strong></p>
<p>The syntax for defining classes in Python is straightforward:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(self, loud=False)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            print(<span class="string">'HELLO, %s!'</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Hello, %s'</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">'Fred'</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints "Hello, Fred"</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints "HELLO, FRED!"</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>Numpy</strong></p>
<p><a href="http://www.numpy.org/">Numpy</a> is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays. If you are already familiar with MATLAB, you might find <a href="https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users.html">this tutorial useful</a> to get started with Numpy.</p>
<ul>
<li><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>A numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The <strong>number of dimensions is the <em>rank</em> of the array</strong>; the <strong><em>shape</em></strong> of an array is a tuple of integers <strong>giving the size of the array along each dimension</strong>.</p>
<p>We can initialize numpy arrays from nested Python lists, and access elements using square brackets:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line">print(type(a))            <span class="comment"># Prints "&lt;class 'numpy.ndarray'&gt;"</span></span><br><span class="line">print(a.shape)            <span class="comment"># Prints "(3,)"</span></span><br><span class="line">print(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints "1 2 3"</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line">print(a)                  <span class="comment"># Prints "[5, 2, 3]"</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line">print(b.shape)                     <span class="comment"># Prints "(2, 3)"</span></span><br><span class="line">print(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints "1 2 4"</span></span><br></pre></td></tr></table></figure>

<p>Numpy also provides many functions to create arrays:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line">print(a)              <span class="comment"># Prints "[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]"</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line">print(b)              <span class="comment"># Prints "[[ 1.  1.]]"</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line">print(c)               <span class="comment"># Prints "[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]"</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line">print(d)              <span class="comment"># Prints "[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]"</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line">print(e)                     <span class="comment"># Might print "[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]"</span></span><br></pre></td></tr></table></figure>

<p>You can read about other methods of array creation <a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation">in the documentation</a>.</p>
</li>
</ul>
<h3 id="Array-indexing"><a href="#Array-indexing" class="headerlink" title="Array indexing"></a>Array indexing</h3><p>  Numpy offers several ways to index into arrays.</p>
<p>  <strong>Slicing:</strong> Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, <strong>you must specify a slice for each dimension of the array:</strong></p>
<p>  <u>A slice of an array is a view into the same data, so modifying it</u></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>] <span class="comment"># :2行 1:3列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints "2"</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line">print(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints "77"</span></span><br></pre></td></tr></table></figure>

<p>  You can also mix integer indexing with slice indexing. However, doing so will yield an array of lower rank than the original array. Note that this is quite different from the way that MATLAB handles array slicing:</p>
<p>  <u>Mixing integer indexing with slices yields an array of lower rank,while using only slices yields an array of the same rank as the original array:</u></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line">print(row_r1, row_r1.shape)  <span class="comment"># Prints "[5 6 7 8] (4,)"</span></span><br><span class="line">print(row_r2, row_r2.shape)  <span class="comment"># Prints "[[5 6 7 8]] (1, 4)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">print(col_r1, col_r1.shape)  <span class="comment"># Prints "[ 2  6 10] (3,)"</span></span><br><span class="line">print(col_r2, col_r2.shape)  <span class="comment"># Prints "[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)"</span></span><br></pre></td></tr></table></figure>

<p>  <strong>Integer array indexing:</strong> <strong>When you index into numpy arrays using slicing, the resulting array view will always be a subarray of the original array</strong>. In contrast, integer array indexing allows you to construct arbitrary arrays using the data from another array. Here is an example:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and 这是因为shape的第一个参数是代表第一个维度的大小</span></span><br><span class="line">print(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints "[1 4 5]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line">print(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints "[1 4 5]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line">print(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints "[2 2]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line">print(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints "[2 2]"</span></span><br></pre></td></tr></table></figure>

<p>  One useful trick with integer array indexing is selecting or mutating one element from each row of a matrix:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">print(a)  <span class="comment"># prints "array([[ 1,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5,  6],</span></span><br><span class="line">          <span class="comment">#                [ 7,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 11, 12]])"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">每一行里通过index取一个数组成一行</span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line">print(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints "[ 1  6  7 11]"</span></span><br><span class="line"></span><br><span class="line">每一行里通过index和+=来</span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">print(a)  <span class="comment"># prints "array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure>

<p>  <strong>Boolean array indexing:</strong> Boolean array indexing lets you pick out arbitrary elements of an array. Frequently this type of indexing is used to select the elements of an array that satisfy some condition. Here is an example:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line">print(bool_idx)      <span class="comment"># Prints "[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line">print(a[bool_idx])  <span class="comment"># Prints "[3 4 5 6]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line">print(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints "[3 4 5 6]"</span></span><br></pre></td></tr></table></figure>

<p>  For brevity we have left out a lot of details about numpy array indexing; if you want to know more you should <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html">read the documentation</a>.</p>
<h3 id="Datatypes"><a href="#Datatypes" class="headerlink" title="Datatypes"></a>Datatypes</h3><p>  Every numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line">print(x.dtype)         <span class="comment"># Prints "int64"</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line">print(x.dtype)             <span class="comment"># Prints "float64"</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line">print(x.dtype)                         <span class="comment"># Prints "int64"</span></span><br></pre></td></tr></table></figure>

<p>  You can read all about numpy datatypes <a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html">in the documentation</a>.</p>
<h3 id="Array-math"><a href="#Array-math" class="headerlink" title="Array math"></a>Array math</h3><p>  Basic mathematical functions operate elementwise on arrays, and are available both as operator overloads and as functions in the numpy module:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line">print(x + y)</span><br><span class="line">print(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line">print(x - y)</span><br><span class="line">print(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line">print(x * y)</span><br><span class="line">print(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line">print(x / y)</span><br><span class="line">print(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line">print(np.sqrt(x))</span><br></pre></td></tr></table></figure>

<p>  Note that unlike MATLAB, <code>*</code> is elementwise multiplication, not matrix multiplication. We instead use the <code>dot</code> function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. <code>dot</code> is available both as a function in the numpy module and as an instance method of array objects:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line">print(x.dot(v))</span><br><span class="line">print(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line">print(x.dot(y))</span><br><span class="line">print(np.dot(x, y))</span><br></pre></td></tr></table></figure>

<p>  Numpy provides many useful functions for performing computations on arrays; one of the most useful is <code>sum</code>:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  <span class="comment"># Compute sum of all elements; prints "10"</span></span><br><span class="line">print(np.sum(x, axis=<span class="number">0</span>))  <span class="comment"># Compute sum of each column; prints "[4 6]"</span></span><br><span class="line">print(np.sum(x, axis=<span class="number">1</span>))  <span class="comment"># Compute sum of each row; prints "[3 7]"</span></span><br></pre></td></tr></table></figure>

<p>  You can find the full list of mathematical functions provided by numpy <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">in the documentation</a>.</p>
<p>  Apart from computing mathematical functions using arrays, we frequently need to reshape or otherwise manipulate data in arrays. The simplest example of this type of operation is transposing a matrix; to transpose a matrix, simply use the <code>T</code> attribute of an array object:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">print(x)    <span class="comment"># Prints "[[1 2]</span></span><br><span class="line">            <span class="comment">#          [3 4]]"</span></span><br><span class="line">print(x.T)  <span class="comment"># Prints "[[1 3]</span></span><br><span class="line">            <span class="comment">#          [2 4]]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that taking the transpose of a rank 1 array does nothing:</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(v)    <span class="comment"># Prints "[1 2 3]"</span></span><br><span class="line">print(v.T)  <span class="comment"># Prints "[1 2 3]"</span></span><br></pre></td></tr></table></figure>

<p>  Numpy provides many more functions for manipulating arrays; you can see the full list <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">in the documentation</a>.</p>
<h3 id="Broadcasting"><a href="#Broadcasting" class="headerlink" title="Broadcasting"></a>Broadcasting</h3><p>  Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations. Frequently we have a smaller array and a larger array, and we want to use the smaller array multiple times to perform some operation on the larger array.</p>
<p>  For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># Create an empty matrix with the same shape as x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the vector v to each row of the matrix x with an explicit loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now y is the following</span></span><br><span class="line"><span class="comment"># [[ 2  2  4]</span></span><br><span class="line"><span class="comment">#  [ 5  5  7]</span></span><br><span class="line"><span class="comment">#  [ 8  8 10]</span></span><br><span class="line"><span class="comment">#  [11 11 13]]</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<p>  This works; however when the matrix <code>x</code> is very large, computing an explicit loop in Python could be slow. Note that adding the vector <code>v</code> to each row of the matrix <code>x</code> is equivalent to forming a matrix <code>vv</code> by stacking multiple copies of <code>v</code> vertically, then performing elementwise summation of <code>x</code> and <code>vv</code>. We could implement this approach like this:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># Stack 4 copies of v on top of each other</span></span><br><span class="line">print(vv)                 <span class="comment"># Prints "[[1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]]"</span></span><br><span class="line">y = x + vv  <span class="comment"># Add x and vv elementwise</span></span><br><span class="line">print(y)  <span class="comment"># Prints "[[ 2  2  4</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]"</span></span><br></pre></td></tr></table></figure>

<p>  Numpy broadcasting allows us to perform this computation without actually creating multiple copies of <code>v</code>. Consider this version, using broadcasting:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># Add v to each row of x using broadcasting</span></span><br><span class="line">print(y)  <span class="comment"># Prints "[[ 2  2  4]</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]"</span></span><br></pre></td></tr></table></figure>

<p>  The line <code>y = x + v</code> works even though <code>x</code> has shape <code>(4, 3)</code> and <code>v</code> has shape <code>(3,)</code> due to broadcasting; this line works as if <code>v</code> actually had shape <code>(4, 3)</code>, where each row was a copy of <code>v</code>, and the sum was performed elementwise.</p>
<p>  Broadcasting two arrays together follows these rules:</p>
<ol>
<li><p>If the arrays do not have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.</p>
</li>
<li><p>The two arrays are said to be <em>compatible</em> in a dimension if they have the same size in the dimension, or if one of the arrays has size 1 in that dimension.</p>
</li>
<li><p>The arrays can be broadcast together if they are compatible in all dimensions.</p>
</li>
<li><p>After broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays.</p>
</li>
<li><p>In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension</p>
<p>If this explanation does not make sense, try reading the explanation <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">from the documentation</a> or <a href="http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">this explanation</a>.</p>
<p>Functions that support broadcasting are known as <em>universal functions</em>. You can find the list of all universal functions <a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">in the documentation</a>.</p>
<p>Here are some applications of broadcasting:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute outer product of vectors</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># v has shape (3,)</span></span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    <span class="comment"># w has shape (2,)</span></span><br><span class="line"><span class="comment"># To compute an outer product, we first reshape v to be a column</span></span><br><span class="line"><span class="comment"># vector of shape (3, 1); we can then broadcast it against w to yield</span></span><br><span class="line"><span class="comment"># an output of shape (3, 2), which is the outer product of v and w:</span></span><br><span class="line"><span class="comment"># [[ 4  5]</span></span><br><span class="line"><span class="comment">#  [ 8 10]</span></span><br><span class="line"><span class="comment">#  [12 15]]</span></span><br><span class="line">print(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each row of a matrix</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span></span><br><span class="line"><span class="comment"># giving the following matrix:</span></span><br><span class="line"><span class="comment"># [[2 4 6]</span></span><br><span class="line"><span class="comment">#  [5 7 9]]</span></span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each column of a matrix</span></span><br><span class="line"><span class="comment"># x has shape (2, 3) and w has shape (2,).</span></span><br><span class="line"><span class="comment"># If we transpose x then it has shape (3, 2) and can be broadcast</span></span><br><span class="line"><span class="comment"># against w to yield a result of shape (3, 2); transposing this result</span></span><br><span class="line"><span class="comment"># yields the final result of shape (2, 3) which is the matrix x with</span></span><br><span class="line"><span class="comment"># the vector w added to each column. Gives the following matrix:</span></span><br><span class="line"><span class="comment"># [[ 5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11]]</span></span><br><span class="line">print((x.T + w).T)</span><br><span class="line"><span class="comment"># Another solution is to reshape w to be a column vector of shape (2, 1);</span></span><br><span class="line"><span class="comment"># we can then broadcast it directly against x to produce the same</span></span><br><span class="line"><span class="comment"># output.</span></span><br><span class="line">print(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiply a matrix by a constant:</span></span><br><span class="line"><span class="comment"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span></span><br><span class="line"><span class="comment"># these can be broadcast together to shape (2, 3), producing the</span></span><br><span class="line"><span class="comment"># following array:</span></span><br><span class="line"><span class="comment"># [[ 2  4  6]</span></span><br><span class="line"><span class="comment">#  [ 8 10 12]]</span></span><br><span class="line">print(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Broadcasting typically makes your code more concise and faster, so you should strive to use it where possible.</p>
<h3 id="Numpy-Documentation"><a href="#Numpy-Documentation" class="headerlink" title="Numpy Documentation"></a>Numpy Documentation</h3><p>This brief overview has touched on many of the important things that you need to know about numpy, but is far from complete. Check out the <a href="http://docs.scipy.org/doc/numpy/reference/">numpy reference</a> to find out much more about numpy.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT Configuration</title>
    <url>/2020/04/02/NexT-Theme-Decoration/</url>
    <content><![CDATA[<h1 id="NexT主题配置-Version-7-8-0"><a href="#NexT主题配置-Version-7-8-0" class="headerlink" title="NexT主题配置(Version 7.8.0)"></a>NexT主题配置(Version 7.8.0)</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本教程面向Hexo NexT主题v7.3.0以上版本，兼容最新v7.8.0版本。</p>
<p>若使用v6.x.x或之前的版本可能会导致不兼容，或文件不存在的问题，本文中也会提醒。</p>
<p>其他Hexo主题不能直接套用，建议自行修改之后再使用。</p>
<a id="more"></a>

<h3 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h3><ul>
<li><p>Hexo目录架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy          #部署文件夹</span><br><span class="line">├── public           #html源码，hexo g生成</span><br><span class="line">├── scaffolds        #模板</span><br><span class="line">├── scripts          #扩展脚本</span><br><span class="line">├── source           #文章源码</span><br><span class="line">|   ├── _drafts      #草稿</span><br><span class="line">|   └── _posts       #文章</span><br><span class="line">├── themes           #主题</span><br><span class="line">|   ├── next         #NexT主题</span><br><span class="line">├── _config.yml      #博客配置</span><br><span class="line">└── package.json     #应用程序数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>NexT目录架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── .github                #github信息</span><br><span class="line">├── languages              #多语言</span><br><span class="line">|   ├── _en.yml            #默认语言</span><br><span class="line">|   └── zh-CN.yml          #简体中文</span><br><span class="line">|   └── zh-TW.yml          #繁体中文</span><br><span class="line">├── layout                 #布局，根目录下的*.swig文件是对主页，分页，存档等的控制</span><br><span class="line">|   ├── _custom            #可以自定义的模板，覆盖原有模板</span><br><span class="line">|   |   ├── head.swig      #文首样式</span><br><span class="line">|   |   ├── header.swig    #头部样式</span><br><span class="line">|   |   ├── sidebar.swig   #侧边栏样式</span><br><span class="line">|   ├── _macro             #可以自定义的模板，覆盖原有模板</span><br><span class="line">|   |   ├── post.swig      #文章模板</span><br><span class="line">|   |   ├── reward.swig    #打赏模板</span><br><span class="line">|   |   ├── sidebar.swig   #侧边栏模板</span><br><span class="line">|   ├── _partial           #局部的布局</span><br><span class="line">|   |   ├── head           #头部模板</span><br><span class="line">|   |   ├── search         #搜索模板</span><br><span class="line">|   |   ├── share          #分享模板</span><br><span class="line">|   ├── _script            #局部的布局</span><br><span class="line">|   ├── _third-party       #第三方模板</span><br><span class="line">|   ├── _layout.swig       #主页面模板</span><br><span class="line">|   ├── index.swig         #主页面模板</span><br><span class="line">|   ├── page               #页面模板</span><br><span class="line">|   └── tag.swig           #tag模板</span><br><span class="line">├── scripts                #script源码</span><br><span class="line">|   ├── tags               #tags的script源码</span><br><span class="line">|   ├── marge.js           #页面模板</span><br><span class="line">├── source                 #源码</span><br><span class="line">|   ├── css                #css源码</span><br><span class="line">|   |   ├── _common        #*.styl基础css</span><br><span class="line">|   |   ├── _custom        #*.styl自定义局部css</span><br><span class="line">|   |   └── _mixins        #mixins的css</span><br><span class="line">|   ├── fonts              #字体</span><br><span class="line">|   ├── images             #图片</span><br><span class="line">|   ├── js                 #javascript源代码</span><br><span class="line">|   └── lib                #引用库</span><br><span class="line">├── _config.yml            #主题配置文件</span><br><span class="line">└── README.md              #说明文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>NexT在v7.3.0之后的版本将所有自定义custom文件转移至Hexo目录<code>source/_data/...</code>中。</p>
</li>
<li><p>了解CSS，swig和js语法</p>
</li>
</ul>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="Hexo-config-yml的配置"><a href="#Hexo-config-yml的配置" class="headerlink" title="Hexo _config.yml的配置"></a>Hexo _config.yml的配置</h3><h4 id="Site设置"><a href="#Site设置" class="headerlink" title="Site设置"></a>Site设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Siriusq</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Hello</span> <span class="string">World!</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">UCLCS</span> <span class="string">NB!</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Sirius</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<p><code>title:</code> 填写标题<br><code>subtitle:</code> 填写副标题<br><code>description:</code> 简介<br><code>keywords:</code> 关键词<br><code>author:</code> 作者，文章中显示的作者名称<br><code>language:</code> 设置语言，zh-CN是简体中文，en是英语，默认是德语</p>
<h4 id="URL栏设置"><a href="#URL栏设置" class="headerlink" title="URL栏设置"></a>URL栏设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://Siriusq.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure>

<p><code>url</code>:填写博客在Github的二级域名，如 <code>https://YourName.github.io</code><br><code>permalink:</code>是生成博客页面时的路径名，一般是:<code>year/:month/:day/:title/</code></p>
<h4 id="翻页设置"><a href="#翻页设置" class="headerlink" title="翻页设置"></a>翻页设置</h4><p>共有两处，用于控制每一页显示多少篇博文</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">12</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br></pre></td></tr></table></figure>

<p><code>per_page:</code>后设置博文数量，0代表不翻页全部平铺显示</p>
<h4 id="Deployment设置"><a href="#Deployment设置" class="headerlink" title="Deployment设置"></a>Deployment设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p><code>branch:</code>分支填写master</p>
<p><code>repo:</code>后把<code>username</code>换成自己的用户名</p>
<h3 id="NexT-config-yml配置"><a href="#NexT-config-yml配置" class="headerlink" title="NexT _config.yml配置"></a>NexT _config.yml配置</h3><h4 id="页脚设置"><a href="#页脚设置" class="headerlink" title="页脚设置"></a>页脚设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2019</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#f08080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo main config will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">Siriusq</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><code>since:</code> 表示网站成立的年份，不设置的话默认是当前年份，显示为<code>© 2019</code><br><code>icon:</code> 中设置年份后面的图标，默认是心形，想修改的话去<a href="https://fontawesome.com/">Fontawesome</a>选择图标，然后再<code>name</code>栏修改<br><code>animated:</code> 用于设置心形是否跳动<br><code>color:</code> 用于设置图标颜色，百度对照色表查就好<br><code>copyright:</code> 显示图标后面的版权所属，也就是作者名，不设置的话默认显示根目录配置文件中的作者名<br><code>powered:</code> 后面的栏目用于设定是否显示<code>Powered by Hexo</code>以及当前主题的版本信息，显示的话设为<code>true</code><br><code>theme:</code> 后面的栏目用于设定是否显示当前主题的版本信息，显示的话将设为<code>true</code></p>
<h4 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">en</span></span><br></pre></td></tr></table></figure>

<p><code>license:</code>用于设置版权标准，具体可以去<a href="https://creativecommons.org/share-your-work/licensing-types-examples">Creative Commons</a>查看<br><code>sidebar:</code>用于设置是否在侧边栏显示版权标准<br><code>post:</code>用于设置是否在文章底部显示版权信息<br><code>language:</code>用于设置语言</p>
<h4 id="Github角标"><a href="#Github角标" class="headerlink" title="Github角标"></a>Github角标</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/Siriusq</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>

<p><code>enable:</code>用于设置是否在页面右上角显示Github三角标<br><code>permalink:</code>后面填写你的Github地址<br><code>title:</code>用于设置鼠标移动到图标后显示的文字</p>
<h4 id="侧边栏菜单设置"><a href="#侧边栏菜单设置" class="headerlink" title="侧边栏菜单设置"></a>侧边栏菜单设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">switch_lang:</span> <span class="string">/en</span> <span class="string">||</span> <span class="string">language</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p><code>||</code>前表示页面的地址，后面表示显示的图标名称<br><code>about:</code>用于设置<code>关于</code>页面，没有的话在Git bash中使用<code>hexo new page &quot;about&quot;</code>创建，然后打开<code>\source\about\index.md</code>就可以编写了<br><code>tags:</code>用于设置<code>标签</code>功能，同样使用命令<code>hexo new page &quot;tags&quot;</code>创建，然后打开<code>source\tags\index.md</code>并在日期后面添加一行<code>type: &quot;tags&quot;</code>，写博文时在顶部加上一栏<code>tags: []</code>即可设置标签，多个标签中间使用<code>,</code>分隔<br><code>archieves:</code>用于设置归档页面<br><code>categories:</code>用于设置目录页面，编辑博文时在顶部加上一栏<code>categories:</code>就可以为博文设置所属目录</p>
<h4 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h4><p>Next有四个主题可供选择</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<p>选择自己喜欢的主题uncomment即可</p>
<h4 id="社交网站链接设置"><a href="#社交网站链接设置" class="headerlink" title="社交网站链接设置"></a>社交网站链接设置</h4><p><strong><em>NexT v7.8.0 email social link bug，暂时没有得到官方的修复</em></strong></p>
<p><strong><em>所设置的</em></strong>  <u>mailto:<a href="mailto:siriuskevin@foxmail.com">siriuskevin@foxmail.com</a></u> <strong><em>在转换为md转html之后会在front多出一个</em></strong><code>/</code></p>
<p><strong><em>该bug可以通过修改源码解决，更多可以查看</em></strong><a href="https://github.com/theme-next/hexo-theme-next/issues/1295">#1295</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/Siriusq</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:siriuskevin@foxmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br></pre></td></tr></table></figure>

<p>在<code>||</code>前输入你社交主页的链接即可，后面用于设置图标<br><code>E-mail:</code>栏格式为<code>mailto:邮箱地址</code>，在win10系统可以调用系统邮件服务自动填写收件人</p>
<h4 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h4><p>用于设置是否在侧边栏显示头像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在<code>url:</code>后填写头像图片的路径，默认在<code>\themes\next\source\images</code>中<br><code>rounded:</code>用于设置是否显示圆形头像<br><code>opacity:</code>用于设置头像透明度，1为不透明<br><code>rotated:</code>用于设置头像鼠标移动到头像上时头像是否旋转</p>
<h4 id="侧边栏目录设置"><a href="#侧边栏目录设置" class="headerlink" title="侧边栏目录设置"></a>侧边栏目录设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front Matter.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><code>enable:</code>用于设置是否开启侧边栏目录<br><code>number:</code>用于设置自动编号<br><code>wrap:</code>用于设置当标题长度超过侧边栏长度时是否自动换行<br><code>expand_all:</code>用于设置是否展开全部目录，否的话会自动展开正在看的那部分<br><code>max_depth:</code>用于设置自动生成目录的最大深度，也就是生成到几级标题</p>
<h4 id="侧边栏显示设置"><a href="#侧边栏显示设置" class="headerlink" title="侧边栏显示设置"></a>侧边栏显示设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available values: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="comment">#position: left</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Manual define the sidebar width. If commented, will be default for:</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">320</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available values (only for Muse | Mist):</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically.</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Click any blank part of the page to close sidebar (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">dimmer:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><code>position:</code>用于设置侧边栏在左边还是右边，把要选择的位置前面的<code>#</code>去掉再把另一个前面加上<code>#</code>即可，这个选项只对<code>Pisces</code>和<code>Gemini</code>两个主题起作用<br><code>width:</code>用于设置侧边栏的宽度，默认<code>Muse</code>和<code>Mist</code>是320,<code>Pisces</code>和<code>Gemini</code>是240<br><code>display:</code>用于设置侧边栏的显示方式，只对<code>Muse</code>和<code>Mist</code>两个主题起作用，可以挨个试一下<br><code>offset:</code>用于设置侧边栏距离顶部介绍的距离，只对<code>Pisces</code>和<code>Gemini</code>两个主题起作用<br><code>onmobile:</code>用于设置是否在手机等宽度较小的设备上显示侧边栏，只对<code>Muse</code>和<code>Mist</code>两个主题起作用<br><code>dimmer:</code>用于设置点击屏幕空白处是否关闭侧边栏，同样只对<code>Muse</code>和<code>Mist</code>两个主题起作用</p>
<h4 id="返回顶部按钮"><a href="#返回顶部按钮" class="headerlink" title="返回顶部按钮"></a>返回顶部按钮</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><code>enable:</code>用于设置是否开启回到顶部按钮<br><code>sidebar:</code>用于设置是否将按钮放到侧边栏中<br><code>scrollpercent:</code>用于设置是否显示阅读进度百分比</p>
<h4 id="开启阅读全文选项"><a href="#开启阅读全文选项" class="headerlink" title="开启阅读全文选项"></a>开启<code>阅读全文</code>选项</h4><p>用搜索找到这一段并把<code>read_more_btn:</code>设为<code>true</code>即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button would be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>下面这一段用于设置自动生成<code>阅读全文</code>选项</p>
<p><strong><em>NexT在7.3版本之后就不再支持auto_excerpt，请添加</em></strong><code>&lt;!-- More --&gt;</code>到文章中手动设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt (Not recommend).</span></span><br><span class="line"><span class="comment"># Use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p><code>length</code>表示截止到的字符长度</p>
<p>这一段用于设置自动跳转到<code>阅读全文</code>选项之后的位置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>设置完成后，在文章内加入``字段就可以在首页隐去剩下的文字并显示<code>阅读全文</code>按钮了</p>
<h4 id="代码块复制按钮"><a href="#代码块复制按钮" class="headerlink" title="代码块复制按钮"></a>代码块复制按钮</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Manual define the border radius in codeblock, leave it blank for the default value: 1</span></span><br><span class="line">  <span class="attr">border_radius:</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Style: only 'flat' is currently available, leave it blank if you prefer default theme</span></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure>

<p><code>enable：</code>用于开启代码块右上角的复制按钮<br><code>show_result:</code>用于设置是否显示复制成功提示</p>
<h4 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward would be displayed in every article by default.</span></span><br><span class="line">  <span class="comment"># You can show or hide reward in a specific article throuth `reward: true | false` in Front Matter.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#comment: Donate comment here</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="comment">#wechatpay: /images/wechatpay.png</span></span><br><span class="line">  <span class="comment">#alipay: /images/alipay.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>

<p><code>enable:</code>用于设置是否在文章末尾显示打赏按钮<br><code>animation:</code>用于设置打上按钮是否显示动画<br><code>reward:</code>后面的选项去掉前面的<code>#</code>即可开启对应的打赏，记得替换成自己的图片，路径在<code>\themes\next\source\images</code></p>
<h4 id="代码块高亮主题"><a href="#代码块高亮主题" class="headerlink" title="代码块高亮主题"></a>代码块高亮主题</h4><p>Next主题内置了tomorrow代码高亮主题，一共有五个，可以去<a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow</a>查看预览效果，在下面的<code>highlight_theme:</code>中改成自己想要的即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available values: normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">night</span></span><br></pre></td></tr></table></figure>

<h4 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h4><p>在左上角显示一个书签按钮可以跳转到上一次设置书签的位置<br>首先执行命令<code>git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark</code>安装<a href="https://github.com/theme-next/theme-next-bookmark">bookmark</a>插件<br>然后在下面的选项中将<code>enable:</code>设置为<code>true</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bookmark Support</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-bookmark</span></span><br><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, save the reading position when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>

<h4 id="黑暗模式"><a href="#黑暗模式" class="headerlink" title="黑暗模式"></a>黑暗模式</h4><p>在config.yml文件中找到darkmode关键字</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>设置为true即可</p>
<h3 id="主题深度美化"><a href="#主题深度美化" class="headerlink" title="主题深度美化"></a>主题深度美化</h3><p><u>这些美化总结一下就是</u>：<strong>可以但没必要</strong></p>
<p>🈶️闲情逸致🉐️可以搞一下，<del>这是一个大坑之后有时间再更</del></p>
<hr>
<h4 id="顶部阅读进度条"><a href="#顶部阅读进度条" class="headerlink" title="顶部阅读进度条"></a>顶部阅读进度条</h4><p>在博文页面顶部添加<a href="https://github.com/theme-next/theme-next-reading-progress">Reading Progress</a>进度条，表示阅读进度，Next主题已内置配置文件</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>切换到Next主题文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br></pre></td></tr></table></figure>

<p>安装模块到<code>source/lib</code>文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-reading-progress <span class="built_in">source</span>/lib/reading_progress</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>打开Next主题路径下的配置文件<code>_config.yml</code>，搜索<code>reading_progress</code>定位到如下代码并将<code>enable:</code>设置为<code>true</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-reading-progress</span></span><br><span class="line">reading_progress:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  color: <span class="string">"#ffc0cb"</span> <span class="comment"># 调整线条颜色</span></span><br><span class="line">  height: 3px <span class="comment"># 调整线条高度</span></span><br></pre></td></tr></table></figure>

<p>线条颜色可以在<a href="http://www.atool9.com/colorpicker.php">ATOOL</a>查询颜色代码直接修改</p>
<h5 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h5><p>切换到安装目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next/<span class="built_in">source</span>/lib/reading_progress</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h4 id="加载条"><a href="#加载条" class="headerlink" title="加载条"></a>加载条</h4><p>用于在网页加载的过程中显示加载进度，Next主题已支持<a href="https://github.com/theme-next/theme-next-pace">PACE</a>功能<br>有多种加载动画可选</p>
<ul>
<li>pace-theme-big-counter</li>
<li>pace-theme-bounce</li>
<li>pace-theme-barber-shop</li>
<li>pace-theme-center-atom</li>
<li>pace-theme-center-circle</li>
<li>pace-theme-center-radar</li>
<li>pace-theme-center-simple</li>
<li>pace-theme-corner-indicator</li>
<li>pace-theme-fill-left</li>
<li>pace-theme-flash</li>
<li>pace-theme-loading-bar</li>
<li>pace-theme-mac-osx</li>
<li>pace-theme-minimal</li>
</ul>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>切换到Next主题文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br></pre></td></tr></table></figure>

<p>安装模块到<code>source/lib</code>文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>打开Next主题路径下的配置文件<code>_config.yml</code>，搜索<code>pace</code>定位到如下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pace</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment"># pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom</span></span><br><span class="line"><span class="comment"># pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment"># pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-flash</span></span><br></pre></td></tr></table></figure>

<p>将<code>pace:</code>设置为<code>true</code><br>将<code>pace_theme:</code>设置为上面<code>Themes list:</code>中的一种，主题样式可以在<a href="https://github.hubspot.com/pace/docs/welcome/">PACE</a>查看</p>
<h5 id="调整颜色"><a href="#调整颜色" class="headerlink" title="调整颜色"></a>调整颜色</h5><p>为了让进度条和主题背景相匹配，可以在<code>./themes/next/source/lib/pace</code>中找到相应主题的css文件并修改颜色配置<br>下面代码以<code>pace-theme-flash.min.css</code>示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.pace</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">-webkit-pointer-events:</span> <span class="string">none;</span></span><br><span class="line">  <span class="attr">pointer-events:</span> <span class="string">none;</span></span><br><span class="line">  <span class="string">-webkit-user-select:</span> <span class="string">none;</span></span><br><span class="line">  <span class="string">-moz-user-select:</span> <span class="string">none;</span></span><br><span class="line">  <span class="attr">user-select:</span> <span class="string">none;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.pace-inactive</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">none;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.pace</span> <span class="string">.pace-progress</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="comment">#ffc0cb;</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">fixed;</span></span><br><span class="line">  <span class="attr">z-index:</span> <span class="number">2000</span><span class="string">;</span></span><br><span class="line">  <span class="attr">top:</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="attr">right:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">2px;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.pace</span> <span class="string">.pace-progress-inner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">block;</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">absolute;</span></span><br><span class="line">  <span class="attr">right:</span> <span class="string">0px;</span></span><br><span class="line">  <span class="attr">width:</span> <span class="string">100px;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">  <span class="attr">box-shadow:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">10px</span> <span class="comment">#ffc0cb, 0 0 5px #ffc0cb;</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1.0</span><span class="string">;</span></span><br><span class="line">  <span class="string">-webkit-transform:</span> <span class="string">rotate(3deg)</span> <span class="string">translate(0px,</span> <span class="string">-4px);</span></span><br><span class="line">  <span class="string">-moz-transform:</span> <span class="string">rotate(3deg)</span> <span class="string">translate(0px,</span> <span class="string">-4px);</span></span><br><span class="line">  <span class="string">-ms-transform:</span> <span class="string">rotate(3deg)</span> <span class="string">translate(0px,</span> <span class="string">-4px);</span></span><br><span class="line">  <span class="string">-o-transform:</span> <span class="string">rotate(3deg)</span> <span class="string">translate(0px,</span> <span class="string">-4px);</span></span><br><span class="line">  <span class="attr">transform:</span> <span class="string">rotate(3deg)</span> <span class="string">translate(0px,</span> <span class="string">-4px);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.pace</span> <span class="string">.pace-activity</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">block;</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">fixed;</span></span><br><span class="line">  <span class="attr">z-index:</span> <span class="number">2000</span><span class="string">;</span></span><br><span class="line">  <span class="attr">top:</span> <span class="string">15px;</span></span><br><span class="line">  <span class="attr">right:</span> <span class="string">15px;</span></span><br><span class="line">  <span class="attr">width:</span> <span class="string">14px;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">14px;</span></span><br><span class="line">  <span class="attr">border:</span> <span class="string">solid</span> <span class="string">2px</span> <span class="string">transparent;</span></span><br><span class="line">  <span class="attr">border-top-color:</span> <span class="comment">#ffc0cb;</span></span><br><span class="line">  <span class="attr">border-left-color:</span> <span class="comment">#ffc0cb;</span></span><br><span class="line">  <span class="attr">border-radius:</span> <span class="string">10px;</span></span><br><span class="line">  <span class="string">-webkit-animation:</span> <span class="string">pace-spinner</span> <span class="string">400ms</span> <span class="string">linear</span> <span class="string">infinite;</span></span><br><span class="line">  <span class="string">-moz-animation:</span> <span class="string">pace-spinner</span> <span class="string">400ms</span> <span class="string">linear</span> <span class="string">infinite;</span></span><br><span class="line">  <span class="string">-ms-animation:</span> <span class="string">pace-spinner</span> <span class="string">400ms</span> <span class="string">linear</span> <span class="string">infinite;</span></span><br><span class="line">  <span class="string">-o-animation:</span> <span class="string">pace-spinner</span> <span class="string">400ms</span> <span class="string">linear</span> <span class="string">infinite;</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="string">pace-spinner</span> <span class="string">400ms</span> <span class="string">linear</span> <span class="string">infinite;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">@-webkit-keyframes</span> <span class="string">pace-spinner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="number">0</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-webkit-transform:</span> <span class="string">rotate(0deg);</span> <span class="attr">transform:</span> <span class="string">rotate(0deg);</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="number">100</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-webkit-transform:</span> <span class="string">rotate(360deg);</span> <span class="attr">transform:</span> <span class="string">rotate(360deg);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@-moz-keyframes</span> <span class="string">pace-spinner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="number">0</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-moz-transform:</span> <span class="string">rotate(0deg);</span> <span class="attr">transform:</span> <span class="string">rotate(0deg);</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="number">100</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-moz-transform:</span> <span class="string">rotate(360deg);</span> <span class="attr">transform:</span> <span class="string">rotate(360deg);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@-o-keyframes</span> <span class="string">pace-spinner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="number">0</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-o-transform:</span> <span class="string">rotate(0deg);</span> <span class="attr">transform:</span> <span class="string">rotate(0deg);</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="number">100</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-o-transform:</span> <span class="string">rotate(360deg);</span> <span class="attr">transform:</span> <span class="string">rotate(360deg);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@-ms-keyframes</span> <span class="string">pace-spinner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="number">0</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-ms-transform:</span> <span class="string">rotate(0deg);</span> <span class="attr">transform:</span> <span class="string">rotate(0deg);</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="number">100</span><span class="string">%</span> <span class="string">&#123;</span> <span class="string">-ms-transform:</span> <span class="string">rotate(360deg);</span> <span class="attr">transform:</span> <span class="string">rotate(360deg);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@keyframes</span> <span class="string">pace-spinner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="number">0</span><span class="string">%</span> <span class="string">&#123;</span> <span class="attr">transform:</span> <span class="string">rotate(0deg);</span> <span class="attr">transform:</span> <span class="string">rotate(0deg);</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="number">100</span><span class="string">%</span> <span class="string">&#123;</span> <span class="attr">transform:</span> <span class="string">rotate(360deg);</span> <span class="attr">transform:</span> <span class="string">rotate(360deg);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用搜索功能搜索<code>#</code>,定位到颜色设置，上述代码中一共有5处，颜色替换方法如下</p>
<ul>
<li>在<a href="http://www.atool9.com/colorpicker.php">ATOOL</a>查询颜色代码直接修改</li>
<li>使用<code>Visual Studio Code</code>安装css插件直接点击<code>#</code>修改颜色</li>
<li>前往<a href="https://github.hubspot.com/pace/docs/welcome/">PACE</a>选择颜色并复制代码直接替换原文件中的代码</li>
</ul>
<p>默认颜色都是蓝色，上述代码修改完后是粉色</p>
<h5 id="升级-1"><a href="#升级-1" class="headerlink" title="升级"></a>升级</h5><p>切换到安装目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next/<span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://choubin.site/2019/12/30/CustomBlogTheme/">hexo 个人博客基于 NexT 主题的基本配置和定制优化</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>Interview - Java Basics</title>
    <url>/2020/04/01/javabasics/</url>
    <content><![CDATA[<h2 id="2-1-Java基础"><a href="#2-1-Java基础" class="headerlink" title="2.1 Java基础"></a>2.1 Java基础</h2><p><a href="https://github.com/Snailclimb/JavaGuide-Interview">Original Blog</a></p>
<h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h3><ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程 ：面向过程性能比面向对象高？？</a></p>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<a id="more"></a>

<h3 id="2-Java-语言有哪些特点"><a href="#2-Java-语言有哪些特点" class="headerlink" title="2. Java 语言有哪些特点?"></a>2. Java 语言有哪些特点?</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<h3 id="3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="4-Oracle-JDK-和-OpenJDK-的对比"><a href="#4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="4. Oracle JDK 和 OpenJDK 的对比"></a>4. Oracle JDK 和 OpenJDK 的对比</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。</a></li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h3 id="5-Java-和-C-的区别"><a href="#5-Java-和-C-的区别" class="headerlink" title="5. Java 和 C++的区别?"></a>5. Java 和 C++的区别?</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<blockquote>
<p>作者：Guide哥。</p>
<p><strong>介绍:</strong> Github 70k Star 项目  <strong><a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></strong>（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取Java工程师必备学习资料+面试突击pdf。</p>
</blockquote>
<h3 id="6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同"><a href="#6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同" class="headerlink" title="6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?"></a>6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p>
<h3 id="7-Java-应用程序与小程序之间有哪些差别"><a href="#7-Java-应用程序与小程序之间有哪些差别" class="headerlink" title="7. Java 应用程序与小程序之间有哪些差别?"></a>7. Java 应用程序与小程序之间有哪些差别?</h3><p>简单说应用程序是从主线程启动(也就是 <code>main()</code> 方法)。applet 小程序没有 <code>main()</code> 方法，主要是嵌在浏览器页面上运行(调用<code>init()</code>或者<code>run()</code>来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p>
<h3 id="8-字符型常量和字符串常量的区别"><a href="#8-字符型常量和字符串常量的区别" class="headerlink" title="8. 字符型常量和字符串常量的区别?"></a>8. 字符型常量和字符串常量的区别?</h3><ol>
<li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<blockquote>
<p>java 编程思想第四版：2.2.2 节<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt=""></p>
</blockquote>
<h3 id="9-构造器-Constructor-是否可被-override"><a href="#9-构造器-Constructor-是否可被-override" class="headerlink" title="9. 构造器 Constructor 是否可被 override?"></a>9. 构造器 Constructor 是否可被 override?</h3><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt=""></p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p>
<h3 id="11-Java-面向对象编程三大特性-封装-继承-多态"><a href="#11-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="11. Java 面向对象编程三大特性: 封装 继承 多态"></a>11. Java 面向对象编程三大特性: 封装 继承 多态</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h3 id="12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3><p><strong>可变性</strong></p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<blockquote>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>
<p><code>AbstractStringBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
<h3 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13. 自动装箱与拆箱"></a>13. 自动装箱与拆箱</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析Java中的装箱和拆箱</a></p>
<h3 id="14-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的?</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h3 id="15-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h3 id="16-import-java-和-javax-有什么区别？"><a href="#16-import-java-和-javax-有什么区别？" class="headerlink" title="16. import java 和 javax 有什么区别？"></a>16. import java 和 javax 有什么区别？</h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h3 id="17-接口和抽象类的区别是什么？"><a href="#17-接口和抽象类的区别是什么？" class="headerlink" title="17. 接口和抽象类的区别是什么？"></a>17. 接口和抽象类的区别是什么？</h3><ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<blockquote>
<p>备注：</p>
<ol>
<li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146">https://github.com/Snailclimb/JavaGuide/issues/146</a>。</li>
<li>jdk9 的接口被允许定义私有方法 。</li>
</ol>
</blockquote>
<p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/">相关阅读</a>）：</p>
<ol>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h3 id="18-成员变量与局部变量的区别有哪些？"><a href="#18-成员变量与局部变量的区别有哪些？" class="headerlink" title="18. 成员变量与局部变量的区别有哪些？"></a>18. 成员变量与局部变量的区别有哪些？</h3><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h3 id="19-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#19-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="20-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#20-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="20. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h3 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h3><ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h3 id="23-静态方法和实例方法有何不同"><a href="#23-静态方法和实例方法有何不同" class="headerlink" title="23. 静态方法和实例方法有何不同"></a>23. 静态方法和实例方法有何不同</h3><ol>
<li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>
</li>
</ol>
<h3 id="24-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#24-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="24. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>24. 对象的相等与指向他们的引用相等,两者有什么不同?</h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作。</p>
<h3 id="26-与-equals-重要"><a href="#26-与-equals-重要" class="headerlink" title="26. == 与 equals(重要)"></a>26. == 与 equals(重要)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h3 id="27-hashCode-与-equals-重要"><a href="#27-hashCode-与-equals-重要" class="headerlink" title="27. hashCode 与 equals (重要)"></a>27. hashCode 与 equals (重要)</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p>
<h4 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong><code>hashCode()</code>在散列表中才有用，在其它情况下没用</strong>。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h4 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h4><ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>
<h3 id="28-为什么-Java-中只有值传递？"><a href="#28-为什么-Java-中只有值传递？" class="headerlink" title="28. 为什么 Java 中只有值传递？"></a>28. 为什么 Java 中只有值传递？</h3><p><a href="https://juejin.im/post/5e18879e6fb9a02fc63602e2">为什么 Java 中只有值传递？</a></p>
<h3 id="29-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#29-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。<br>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h3 id="30-线程有哪些基本状态"><a href="#30-线程有哪些基本状态" class="headerlink" title="30. 线程有哪些基本状态?"></a>30. 线程有哪些基本状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h3 id="31-关于-final-关键字的一些总结"><a href="#31-关于-final-关键字的一些总结" class="headerlink" title="31 关于 final 关键字的一些总结"></a>31 关于 final 关键字的一些总结</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
<h3 id="32-Java-中的异常处理"><a href="#32-Java-中的异常处理" class="headerlink" title="32 Java 中的异常处理"></a>32 Java 中的异常处理</h3><h4 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h4><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png" alt="Java异常类层次结构图"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</p>
<p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。</font>Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p>
<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>
<h4 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h4><ul>
<li><strong>public string getMessage()</strong>:返回异常发生时的简要描述</li>
<li><strong>public string toString()</strong>:返回异常发生时的详细信息</li>
<li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同</li>
<li><strong>public void printStackTrace()</strong>:在控制台上打印 Throwable 对象封装的异常信息</li>
</ul>
<h4 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h4><ul>
<li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return<br>语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p>
<ol>
<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>
<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h3 id="33-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#33-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="33 Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>33 Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="34-获取用键盘输入常用的两种方法"><a href="#34-获取用键盘输入常用的两种方法" class="headerlink" title="34 获取用键盘输入常用的两种方法"></a>34 获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="35-Java-中-IO-流"><a href="#35-Java-中-IO-流" class="headerlink" title="35 Java 中 IO 流"></a>35 Java 中 IO 流</h3><h4 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h4><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p>
<h4 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h4 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h4><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h3 id="36-常见关键字总结-static-final-this-super"><a href="#36-常见关键字总结-static-final-this-super" class="headerlink" title="36. 常见关键字总结:static,final,this,super"></a>36. 常见关键字总结:static,final,this,super</h3><p>详见笔主的这篇文章:  <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/final,static,this,super.md">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/final,static,this,super.md</a></p>
<h3 id="37-Collections-工具类和-Arrays-工具类常见方法总结"><a href="#37-Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="37. Collections 工具类和 Arrays 工具类常见方法总结"></a>37. Collections 工具类和 Arrays 工具类常见方法总结</h3><p>详见笔主的这篇文章:  <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></p>
<h3 id="38-深拷贝-vs-浅拷贝"><a href="#38-深拷贝-vs-浅拷贝" class="headerlink" title="38. 深拷贝 vs 浅拷贝"></a>38. 深拷贝 vs 浅拷贝</h3><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li>
<li><a href="https://www.educba.com/oracle-vs-openjdk/">https://www.educba.com/oracle-vs-openjdk/</a></li>
<li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>basics</tag>
      </tags>
  </entry>
  <entry>
    <title>「剑指Offer系列题解」</title>
    <url>/2020/07/20/%E5%89%91%E6%8C%87Offer_%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="剑指Offer-解题记录"><a href="#剑指Offer-解题记录" class="headerlink" title="剑指Offer_解题记录"></a>剑指Offer_解题记录</h1><ul>
<li>📝分享和记录做题的思路</li>
<li>哈哈</li>
</ul>
<a id="more"></a>

<h2 id="Commonly-Used-Class"><a href="#Commonly-Used-Class" class="headerlink" title="Commonly Used Class"></a>Commonly Used Class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition of a single-linked list node</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> ListNode next;</span><br><span class="line"> ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,Node _left,Node _right)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Commonly-Used-Data-Structures"><a href="#Commonly-Used-Data-Structures" class="headerlink" title="Commonly Used Data Structures"></a>Commonly Used Data Structures</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><a href="https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html">HashSet</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashSet最重要的特性就是：不接受重复的元素，两个元素的比较不是用==而是用equals方法，也就是说Set不接受两个对象</span></span><br><span class="line"><span class="comment">// HashSet的实战例子：找到一个数组中第一个重复的元素	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">HashSet( )<span class="comment">//构造一个空的Set，其实HashSet的实例的默认大小是16，加载因子是0.75</span></span><br><span class="line">HashSet(Collection&lt;? extends E&gt; c)<span class="comment">//包含一个Collection中的元素的新set</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity)<span class="comment">//构造一个设定好大小的set</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)<span class="comment">//构造一个设定好大小和加载因子的set</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// HashSet中添加元素</span></span><br><span class="line">hashset.add(<span class="string">"abc"</span>);<span class="comment">//向hashset中添加一个整数</span></span><br><span class="line">hashset.add(<span class="number">1</span>);<span class="comment">//向hashset中添加一个字符</span></span><br><span class="line">hashset.add(<span class="string">'a'</span>);<span class="comment">//向hashset中添加一个数组</span></span><br><span class="line"><span class="keyword">int</span>[] abc=&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">hashset.add(abc);<span class="comment">//向hashset中添加一个自定义对象</span></span><br><span class="line">Cat cat1=<span class="keyword">new</span> Cat(<span class="string">"asd"</span>, <span class="number">2</span>);</span><br><span class="line">hashset.add(cat1);<span class="comment">//向hashset中添加一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历HashSet</span></span><br><span class="line">Iterator it = hashset.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">  Object obj = it.next();</span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer)</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"Integer:"</span>+obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"String:"</span>+obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Character)</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"Character:"</span>+obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="keyword">int</span>[])</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.print(<span class="string">"int[]:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;abc.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.print(abc[i]+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet常用方法</span></span><br><span class="line">hashset.add(E e)：<span class="comment">//返回boolean型，如果此 set 中尚未包含指定元素，则添加指定元素；如果此 set 已包含该元素，则该调用不更改 set 并返回 false。</span></span><br><span class="line"><span class="comment">//删除元素：</span></span><br><span class="line">hashset.clear()<span class="comment">//从此 set 中移除所有元素。</span></span><br><span class="line">hashset.remove(Object o)<span class="comment">//如果指定元素存在于此 set 中，则将其移除。</span></span><br><span class="line">hashset.isEmpty()<span class="comment">//如果此 set 不包含任何元素，则返回 true。</span></span><br><span class="line">hashset.contains(Object o)<span class="comment">//如果此 set 包含指定元素，则返回 true。</span></span><br><span class="line">hashset.size()<span class="comment">//返回此 set 中的元素的数量（set 的容量）。</span></span><br></pre></td></tr></table></figure>



<h3 id="String"><a href="#String" class="headerlink" title="String"></a><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">String</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总结String常用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//charAt()方法经常跟StringBuilder一起用</span></span><br><span class="line">sb.append(String s.charAt(<span class="number">0</span>));</span><br><span class="line">sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取</span></span><br><span class="line"> <span class="number">1.1</span>：字符串中包含的字符数，也就是字符串的长度。</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:获取长度</span></span><br><span class="line"><span class="function"> 1.2：根据位置获取位置上某个字符。</span></span><br><span class="line"><span class="function">  <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"> 1.3：根据字符获取该字符在字符串中的位置。</span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>:返回的是ch在字符串中第一次出现的位置。</span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span>:从fromIndex指定位置开始，获取ch在字符串中出现的位置。</span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>:返回的是str在字符串中第一次出现的位置。</span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str，<span class="keyword">int</span> fromIndex)</span>:从fromIndex指定位置开始，获取str在字符串中出现的位置。</span></span><br><span class="line"><span class="function"> 1.4：<span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>:反向索引。</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="comment">//2.判断</span></span></span><br><span class="line"><span class="function"> 2.1：字符串中是否包含某一个子串。</span></span><br><span class="line"><span class="function">      <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(str)</span></span>;</span><br><span class="line">   特殊之处：indexOf(str):可以索引str第一次出现为止，如果返回-<span class="number">1</span>，表示该str不在字符串中存在。</span><br><span class="line">             所以，也可以用于对指定判断是否包含。</span><br><span class="line">       <span class="keyword">if</span>(str.indexOf(<span class="string">"a"</span>)!=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       而且该方法既可以判断，也可以获取出现的位置。</span><br><span class="line"></span><br><span class="line"> <span class="number">2.2</span>：字符串中是否有内容。</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>:原理就是判断长度是否为0。</span></span><br><span class="line"><span class="function"> 2.3：字符串是否以指定内容开头。</span></span><br><span class="line"><span class="function">   		<span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(str)</span></span>;</span><br><span class="line"> <span class="number">2.4</span>：字符串是否以指定内容结尾。</span><br><span class="line">   		<span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(str)</span></span>;</span><br><span class="line"> <span class="number">2.5</span>：判断字符内容是否相同，复写了object类中的equals方法。</span><br><span class="line">   		<span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(str)</span></span>;</span><br><span class="line"> <span class="number">2.6</span>:判断内容是否相同，并忽略大小写。</span><br><span class="line">  		<span class="keyword">boolean</span>.equalsIgnorecase();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.转换</span></span><br><span class="line"> <span class="number">3.1</span>：将字符数组转成字符串。</span><br><span class="line">  构造函数：String(<span class="keyword">char</span>[])</span><br><span class="line">      String(<span class="keyword">char</span>[],offset,count):将字符数组中的一部分转成字符串</span><br><span class="line"> </span><br><span class="line">  静态方法：</span><br><span class="line">     <span class="function"><span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span>[])</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span>[] data,<span class="keyword">int</span> offset,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[])</span></span>; <span class="comment">//也将其他类型的参数转换成string</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">3.2</span>：将字符串转成字符组</span><br><span class="line">  <span class="keyword">char</span>[] tocharArray();</span><br><span class="line"></span><br><span class="line"> <span class="number">3.3</span>：将字节数组转成字符串。</span><br><span class="line">      String(<span class="keyword">byte</span>[])</span><br><span class="line">      String(<span class="keyword">byte</span>[],offset,count):将字节数组中的一部分转成字符串</span><br><span class="line"> </span><br><span class="line"> <span class="number">3.4</span>：将字符串转成字节数组。</span><br><span class="line">  <span class="keyword">byte</span>[] getBytes()</span><br><span class="line"></span><br><span class="line"> <span class="number">3.5</span>:将基本数据类型转成字符串，</span><br><span class="line"> <span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="comment">// 3+"" 与 String.valueOf(3)的值是一样的</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> 特殊：字符串和字节数组在转换过程中，是可以指定编码的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//4.替换</span></span></span><br><span class="line"><span class="function"> String <span class="title">replace</span><span class="params">(oldchar,newchar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.切割</span></span><br><span class="line"> String[] split(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.子串。获取字符串中的而一部分</span></span><br><span class="line"> <span class="function">String <span class="title">subString</span><span class="params">(begin)</span></span>;</span><br><span class="line"> <span class="function">String <span class="title">subString</span><span class="params">(begin,end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.转换，去除空格，比较。</span></span><br><span class="line"> <span class="number">7.1</span>：将字符串转成大写或小写</span><br><span class="line">   <span class="function">String <span class="title">toUpperCsae</span><span class="params">()</span> 大转小</span></span><br><span class="line"><span class="function">   String <span class="title">toLowerCsae</span><span class="params">()</span> 小转大</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> 7.2：将字符串两端的多个空格去除</span></span><br><span class="line"><span class="function">   String <span class="title">trim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="number">7.3</span>：对两个字符串进行自然顺序的比较</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(string)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历特点： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序</span></span><br><span class="line"><span class="comment">//中序遍历特点： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序</span></span><br><span class="line"><span class="comment">//后序遍历特点： 节点按照 [ 左子树 | 右子树 | 跟节点 ] 排序</span></span><br><span class="line"></span><br><span class="line">二叉搜索树（Binary Search Tree）它或者是一棵空树，或者是具有下列性质的二叉树：左子树上所有结点的值均小于它的根结点的值；右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</span><br></pre></td></tr></table></figure>





<h2 id="Tree-1"><a href="#Tree-1" class="headerlink" title="Tree"></a>Tree</h2><h3 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07-重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">07-重建二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据给出的树的前序遍历和中序遍历重构树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_07_0</span></span>&#123;</span><br><span class="line">    <span class="comment">// 解题的原理是：pre order遍历的第一个元素是root 利用这个root到in order遍历分为左子树和右子树，然后左右子树向下递归</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//记录in order遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder; <span class="comment">// 记录pre order 的数组，递归方法中需要用到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preorder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inorder 中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder; <span class="comment">//存入preOrder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.length;i++)</span><br><span class="line">            <span class="comment">// inOrdre元素:index</span></span><br><span class="line">            map.put(inorder[i],i); <span class="comment">//记录中序遍历中每一个元素的index</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>); <span class="comment">//preRootIndex为0是因为要从preorder的第一个也就是整个树的root开始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preRoot 前序遍历中root的索引(index)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inLeft 中序遍历的左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inRight 中序边界汇总的右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> preRoot, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inLeft &gt; inRight) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果左边界大于右边界说明inOrder数组中越界了 直接返回null</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preRoot]); <span class="comment">//new一个root的TreeNode对象</span></span><br><span class="line">        <span class="keyword">int</span> inRoot = map.get(preorder[preRoot]); <span class="comment">//通过前序遍历的index来得到中序遍历中当前元素的index</span></span><br><span class="line">        <span class="comment">//因为已经知道该元素在中序遍历中的index，我们就可以区分出左右子树</span></span><br><span class="line">        root.left = recur(preRoot+<span class="number">1</span>,inLeft,inRoot-<span class="number">1</span>); <span class="comment">//左子树</span></span><br><span class="line">        <span class="comment">// 右子树root在前序遍历中的index = 当前root在前序遍历的index + (当前root在中序遍历中的index-中序遍历左边界)(这个是左子树的长度) +1(再加一)</span></span><br><span class="line">        root.right = recur(preRoot+(inRoot-inLeft)+<span class="number">1</span>,inRoot+<span class="number">1</span>,inRight); <span class="comment">//右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26-树的子结构 "></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">26-树的子结构 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_26_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 因为给出的AB都是root，所以每一层只需要判断两个root本身的val和左右两个子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A==<span class="keyword">null</span> || B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//AB只要有一方是null则</span></span><br><span class="line">        <span class="comment">//先看root是否匹配，在看root的左右子树是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> isRootSubStructure(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRootSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 如果B这边往下找都找到null也没有找出不同，则说明是子树</span></span><br><span class="line">        <span class="keyword">if</span> (A==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 如果A找到null但是B还没有找到null，说明B不是A的子树</span></span><br><span class="line">        <span class="keyword">if</span> (A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//AB的val都不一样 B肯定不是子树</span></span><br><span class="line">        <span class="comment">//如果当前AB相同则往左右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> isRootSubStructure(A.left,B.left) &amp;&amp; isRootSubStructure(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27-二叉树的镜像 "></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">27-二叉树的镜像 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_27_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将当前root上的左右子树的root互换</span></span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32-1 -从上往下打印二叉树 "></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">32-1 -从上往下打印二叉树 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_32_1_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">// 从上到下遍历二叉树，用BFS</span></span><br><span class="line">        <span class="comment">// BFS需要用到queue队列的FIFO先入先出特性</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root); <span class="comment">// 先把root添加到queue中</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 在循环中，先把root拿出来，把值存到ArrayList中</span></span><br><span class="line">            <span class="comment">// 如果左右子树不为null，则添加到queue中，继续循环</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="comment">// 把List中的值拿出来存到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-2-从上往下打印二叉树-2"><a href="#32-2-从上往下打印二叉树-2" class="headerlink" title="32-2 -从上往下打印二叉树 2"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">32-2 -从上往下打印二叉树 2</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        整体思路和上一题差不多，不同点在于把每一层的node.val都集中在一个List中</span></span><br><span class="line"><span class="comment">        用for loop来把同一层的node全添加到list中并且把每次循环中</span></span><br><span class="line"><span class="comment">        当前的node的left和right child node全添加到queue中</span></span><br><span class="line"><span class="comment">        结束for loop后用res添加list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=queue.size(); i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-3-从上往下打印二叉树-3"><a href="#32-3-从上往下打印二叉树-3" class="headerlink" title="32-3 -从上往下打印二叉树 3"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">32-3 -从上往下打印二叉树 3</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_32_3_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，</span></span><br><span class="line"><span class="comment">    第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size()%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                    list.addFirst(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.addLast(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33-二叉搜索树的后序遍历序列 "></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">33-二叉搜索树的后序遍历序列 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_33_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 题目要求如果是空数组 返回true而不是false</span></span><br><span class="line">        recur(postorder,-,postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">// j=postorder.length-1 根据后序遍历得知j是根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=j) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 设置递归终止条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = i; <span class="comment">// 设置一个来找到区分左右子树的index 的 counter</span></span><br><span class="line">        <span class="keyword">while</span> (postorder[p]&lt;postorder[j]) p++; <span class="comment">// 因为左子树的值小于根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = p; <span class="comment">// m是区分左右子树的index, (1,m-1)左子树, (m,j-1)右子树</span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++; <span class="comment">// 右子树的节点值大于根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> verified = p==j; <span class="comment">// 判断当前这个树是否符合二叉搜索树，如果符合，p经历两个while loop就应该到达根节点处</span></span><br><span class="line">        <span class="keyword">return</span> verified &amp;&amp; recur(postorder,i,m-<span class="number">1</span>) &amp;&amp; recur(postorder,m,j-<span class="number">1</span>); <span class="comment">// 递归左右子树是否符合二叉搜索树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34-二叉树中和为某一值的路径 "></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">34-二叉树中和为某一值的路径 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_34_0</span></span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">// 记录每一条path</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 记录当前path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">        recur(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode node,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 设置递归条件：如果当前node为null，则递归方法结束</span></span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        target -= node.val; <span class="comment">// target减去当前节点上的值来更新target</span></span><br><span class="line">        path.add(node.val); <span class="comment">// path添加当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span> &amp;&amp; node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path)); <span class="comment">// 如果到达叶子处且target为0说明这条path满足条件，添加到res中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recur(node.left,target); <span class="comment">// 递归左右子树</span></span><br><span class="line">        recur(node.right,target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 路径恢复：向上回溯，如果当前path加上node.left时target不为0，则删掉node.left回到上一层，并之后尝试node.right</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36-二叉搜索树与双向链表 "></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">36-二叉搜索树与双向链表 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_36_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</span></span><br><span class="line"><span class="comment">    排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点；</span></span><br><span class="line"><span class="comment">    双向链表： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre.right=cur，也应 cur.left=pre</span></span><br><span class="line"><span class="comment">    循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left=tail 和 tail.right=head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node pre,head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        pre.right = head;</span><br><span class="line">        head.left = pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 设置递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dfs(cur.left); <span class="comment">//向下递归，已知二叉搜索树的最左下角的node的值是最小，所以用作head</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre==<span class="keyword">null</span>)&#123;</span><br><span class="line">            head = cur; <span class="comment">//已知二叉搜索树的最左下角的node的值是最小，所以用作head</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = cur; <span class="comment">// 不为null说明不是head，那就正常连接pre和cur</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.left = pre; <span class="comment">// 双向连接</span></span><br><span class="line"></span><br><span class="line">        pre = cur; <span class="comment">//最后更新pre</span></span><br><span class="line">        dfs(cur.right); <span class="comment">// 递归右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55-1-二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">55-1-二叉树的深度</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_55_1_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123; <span class="comment">// for loop将每一层中的节点都弹出 并且加上这些节点的子节点</span></span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++; <span class="comment">// 结束一个for loop代表结束一层 那么深度+1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55-2-平衡二叉树 "></a><a href="">55-2-平衡二叉树 </a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28-对称的二叉树 "></a><a href="">28-对称的二叉树 </a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37-序列化二叉树 "></a><a href="">37-序列化二叉树 </a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54-二叉搜索树的第k大节点"></a><a href="http://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">54-二叉搜索树的第k大节点</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h2><h3 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06-从尾到头打印链表 "></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">06-从尾到头打印链表 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadTailLinkedNode_06</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span></span><br><span class="line"><span class="comment">     * 示例 1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：head = [1,3,2]</span></span><br><span class="line"><span class="comment">     * 输出：[2,3,1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_06_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个arraylist来储存从尾到头的element</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="comment">//创建一个list大小的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这是一个递归方法</span></span><br><span class="line"><span class="comment">         * 终止条件：当node为null的时候说明已经到尾巴了</span></span><br><span class="line"><span class="comment">         * 当终止递归的时候开始回朔</span></span><br><span class="line"><span class="comment">         * 回朔会从尾巴到头一个一个的通过list.add(node.val)把值加到list中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(node.next);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="22-链表中倒数第k个结点"><a href="#22-链表中倒数第k个结点" class="headerlink" title="22-链表中倒数第k个结点 "></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">22-链表中倒数第k个结点 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getKthFromEnd_22</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回链表 4-&gt;5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_22_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是递归的解法</span></span><br><span class="line"><span class="comment">     * 通过递归得到一个储存从尾到头的元素的list</span></span><br><span class="line"><span class="comment">     * 然后直接通过index k 来得到答案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> FindOrNot = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先递归，把element从尾巴到头储存到list中</span></span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递归解决</span></span><br><span class="line"><span class="comment">         * 从尾巴到头依次把element加到list中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(node.next);</span><br><span class="line">        list.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution_22_1</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这题用双指针</span></span><br><span class="line"><span class="comment">     * 算法流程：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head​ 。</span></span><br><span class="line"><span class="comment">     * 构建双指针距离： 前指针 former 先向前走 kkk 步（结束后，双指针 former 和 latter 间相距 kkk 步）。</span></span><br><span class="line"><span class="comment">     * 双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点 时跳出（跳出后， latter 与尾节点距离为 k−1k-1k−1，即 latter 指向倒数第 kkk 个节点）。</span></span><br><span class="line"><span class="comment">     * 返回值： 返回 latter 即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个指针最初都指向head</span></span><br><span class="line">        ListNode former=head, latter=head;</span><br><span class="line">        <span class="comment">//先让former指针移动k个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">//如果只有一个node就是head，则直接返回latter</span></span><br><span class="line">            <span class="keyword">if</span> (former==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            former = former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当former移动到头，也就是当former等于null的时候，latter就到达倒数第k个element，这时再返回latter</span></span><br><span class="line">        <span class="keyword">while</span>(former!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24-反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">24-反转链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseList_24</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment">     * 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_24_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是一个土办法</span></span><br><span class="line"><span class="comment">     * 先用list从尾到头来储存node的值</span></span><br><span class="line"><span class="comment">     * 然后利用递归把每一个node的val更换为list中已经反转的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        recur1(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先用递归把所有的node存起来</span></span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(node.next);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur1</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        node.val=list.get(i++);</span><br><span class="line">        recur1(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25-合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">25-合并两个排序的链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mergeTwoLists_25</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">     * 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_25_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//伪头点</span></span><br><span class="line">    ListNode dum = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//cur先指向dum</span></span><br><span class="line">    ListNode cur = dum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur往前更新一步</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next=l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35-复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35-复杂链表的复制</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copyRandomList_35</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，</span></span><br><span class="line"><span class="comment">     * 每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_35_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用HashMap来解题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建map</span></span><br><span class="line">        HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//指向head</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//复制Node</span></span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(cur,<span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次指向head</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//复制Node的random和next</span></span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52-两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52-两个链表的第一个公共节点</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getIntersectionNode_52</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span></span><br><span class="line"><span class="comment">     * 输出：Reference of the node with value = 8</span></span><br><span class="line"><span class="comment">     * 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_52_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果两个无环链表相交,那么从相交节点开始,一直到两个链表终止的这一段,是两个链表共享的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因此解决该问题的具体过程如下:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     链表1从头节点开始，走到最后一个节点(不是结束)，统计链表1的长度记为len1，同时记录链表1的最后一个节点记为end1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     链表2从头节点开始，走到最后一个节点(不是结束)，统计链表2的长度记为len2，同时记录链表2的最后一个节点记为end2。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     如果end1!=end2，说明两个链表不相交，返回nul即可。如果end=end2，说明两个链表相交，进入步骤4来找寻第一个相交节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     如果链表1比较长，链表1就先走len1-len2步。如果链表2比较长，链表2就先走len2-len1步。然后两个链表一起走，一起走的过程中，两个链表第一次走到一起的那个节点，就是第一个相交的节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lenA=<span class="number">0</span>, lenB=<span class="number">0</span>;</span><br><span class="line">        ListNode curA = headA, curB = headB;</span><br><span class="line">        <span class="comment">//计算lenA</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算lenB</span></span><br><span class="line">        <span class="keyword">while</span> (curB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果end1!=end2，说明两个链表不相交，返回nul即可。如果end=end2，说明两个链表相交，进入步骤4来找寻第一个相交节点。</span></span><br><span class="line">        <span class="keyword">int</span> dif = (lenA-lenB);</span><br><span class="line">        curA = dif&gt;<span class="number">0</span> ? headA : headB;</span><br><span class="line">        curB = curA==headA ? headB : headA;</span><br><span class="line">        dif = Math.abs(dif);</span><br><span class="line">        <span class="keyword">if</span> (dif&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (dif &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在两个链表一起走，等两个node相等的时候就返回，因为找到了intersect point</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=curB)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回curA curB都行，因为相同</span></span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18-删除链表的节点 "></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">18-删除链表的节点 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">deleteNode_18</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回删除后的链表的头节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：此题对比原题有改动</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: head = [4,5,1,9], val = 5</span></span><br><span class="line"><span class="comment">     * 输出: [4,1,9]</span></span><br><span class="line"><span class="comment">     * 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: head = [4,5,1,9], val = 1</span></span><br><span class="line"><span class="comment">     * 输出: [4,5,9]</span></span><br><span class="line"><span class="comment">     * 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_18_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     删除值为 val 的节点可分为两步：定位节点、修改引用。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。</span></span><br><span class="line"><span class="comment">         *     修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (head.val==val) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="comment">//创建指针</span></span><br><span class="line">        ListNode cur = head, pre = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到目标节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur.val!=val)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到目标节点前面的一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(count-<span class="number">1</span>);i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除目标节点</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><h3 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09-用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/submissions/">09-用两个栈实现队列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * ["CQueue","appendTail","deleteHead","deleteHead"]</span></span><br><span class="line"><span class="comment"> * [[],[3],[],[]]</span></span><br><span class="line"><span class="comment"> * 输出：[null,null,3,-1]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * ["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]</span></span><br><span class="line"><span class="comment"> * [[],[],[5],[2],[],[]]</span></span><br><span class="line"><span class="comment"> * 输出：[null,-1,null,null,5,2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CQueue_09</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue_09</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，</span></span><br><span class="line"><span class="comment">         * 因此我们可以设计栈 A 用于加入队尾操作，</span></span><br><span class="line"><span class="comment">         * 栈 B 用于将元素倒序，从而实现删除队首元素。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//A用于加入队尾</span></span><br><span class="line">        <span class="comment">//63</span></span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除队首deleteHead()函数： 有以下三种情况。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</span></span><br><span class="line"><span class="comment">         *     否则，当 A 为空： 即两个栈都为空，无元素，因此返回 −1 。</span></span><br><span class="line"><span class="comment">         *     否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty() &amp;&amp; B.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (B.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//这里用addFirst来实现倒序</span></span><br><span class="line">                <span class="comment">//36</span></span><br><span class="line">                B.addLast(A.removeLast());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6</span></span><br><span class="line">            <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30-包含min函数的栈"></a><a href="http://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">30-包含min函数的栈</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack_30</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack_30</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 函数设计：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     push(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。</span></span><br><span class="line"><span class="comment">         *         将 xxx 压入栈 AAA （即 A.add(x) ）；</span></span><br><span class="line"><span class="comment">         *         若 ① 栈 BBB 为空 或 ② xxx 小于等于 栈 BBB 的栈顶元素，则将 xxx 压入栈 BBB （即 B.add(x) ）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     pop() 函数： 重点为保持栈 A,B 的 元素一致性 。</span></span><br><span class="line"><span class="comment">         *         执行栈 AAA 出栈（即 A.pop() ），将出栈元素记为 yyy ；</span></span><br><span class="line"><span class="comment">         *         若 yyy 等于栈 BBB 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     top() 函数： 直接返回栈 AAA 的栈顶元素即可，即返回 A.peek() 。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     min() 函数： 直接返回栈 BBB 的栈顶元素即可，即返回 B.peek() 。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//把x push到A</span></span><br><span class="line">      	A.add(x);</span><br><span class="line">        <span class="comment">//需要保持 B栈 是非严格降序</span></span><br><span class="line">      	<span class="comment">//Stack类一定要用empty()别用错，用错成isEmpty()会报错</span></span><br><span class="line">        <span class="keyword">if</span> (B.Empty() || x&lt;=B.peek())&#123;</span><br><span class="line">            <span class="comment">//如果B是空 则把x push到B</span></span><br><span class="line">            B.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer popedInt = A.pop();</span><br><span class="line">        <span class="keyword">if</span> (popedInt.equals(B.peek())) B.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31-栈的压入、弹出序列 "></a><a href="">31-栈的压入、弹出序列 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">validateStackSequences_31</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：我们可以按以下顺序执行：</span></span><br><span class="line"><span class="comment"> * push(1), push(2), push(3), push(4), pop() -&gt; 4,</span></span><br><span class="line"><span class="comment"> * push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 解释：1 不能在 2 之前弹出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_31_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     入栈操作： 按照压栈序列的顺序执行。</span></span><br><span class="line"><span class="comment">     *     出栈操作： 每次入栈后，循环判断 “栈顶元素 === 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。</span></span><br><span class="line"><span class="comment">     *     因而，在遇到 “栈顶元素 === 弹出序列的当前元素” 就应立即执行出栈。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法流程：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     初始化： 辅助栈 stackstackstack ，弹出序列的索引 iii ；</span></span><br><span class="line"><span class="comment">     *     遍历压栈序列： 各元素记为 numnumnum ；</span></span><br><span class="line"><span class="comment">     *         元素 numnumnum 入栈；</span></span><br><span class="line"><span class="comment">     *         循环出栈：若 stackstackstack 的栈顶元素 === 弹出序列元素 popped[i]popped[i]popped[i] ，则执行出栈与 i++i++i++ ；</span></span><br><span class="line"><span class="comment">     *     返回值： 若 stackstackstack 为空，则此弹出序列合法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按照顺序依次push element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek().equals(popped[n]))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58-1-翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">58-1-翻转单词顺序</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseWords_58_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 1：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "the sky is blue"</span></span><br><span class="line"><span class="comment">     * 输出: "blue is sky the"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 2：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "  hello world!  "</span></span><br><span class="line"><span class="comment">     * 输出: "world! hello"</span></span><br><span class="line"><span class="comment">     * 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例 3：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入: "a good   example"</span></span><br><span class="line"><span class="comment">     * 输出: "example good a"</span></span><br><span class="line"><span class="comment">     * 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">     * 链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</span></span><br><span class="line"><span class="comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_58_1_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//trim()删除首尾空格 split(" ")用空格分割字符串</span></span><br><span class="line">        String[] strings = s.trim().split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=strings.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//如果stringbuilder里的string是空单词 就跳过进入下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> (strings[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            stringBuilder.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">59 - I. 滑动窗口的最大值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maxSlidingWindow_59_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_59_1_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span> || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化返回的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>-k,j=<span class="number">0</span>;j&lt;nums.length; i++,j++)&#123;</span><br><span class="line">            <span class="comment">//通过removefirst来删除deque中和nums对应的element</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; deque.peekFirst()==nums[i-<span class="number">1</span>]) deque.removeFirst();</span><br><span class="line">            <span class="comment">//while递减deque</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;nums[j]) deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>) res[i]=deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="40-最小的K个数"><a href="#40-最小的K个数" class="headerlink" title="40-最小的K个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">40-最小的K个数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getLeastNumbers_40</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span> || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">        Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * This method returns the value zero if (x==y),</span></span><br><span class="line"><span class="comment">                 * if (x &lt; y) then it returns a value less than zero</span></span><br><span class="line"><span class="comment">                 * and if (x &gt; y) then it returns a value greater than zero.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o2,o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            <span class="comment">//如果e小于当前heap中栈顶的最大的元素才添加e</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size()&lt;k || heap.peek()&gt;e) heap.offer(e);</span><br><span class="line">            <span class="comment">//如果当前heap的size大于k则把栈顶元素弹出去</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size()&gt;k) heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将heap中最小的k个数加入到res数组里并return</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap)&#123;</span><br><span class="line">            res[i++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50-第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50-第一个只出现一次的字符</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c:sc)&#123;</span><br><span class="line">    <span class="comment">//!dic.containsKey(c)导致第一次添加key的时候，value是true，但是再次添加的时候就是false</span></span><br><span class="line">    <span class="comment">//跟本题符合，因为只需要出现依次的char，也就是说如果value为false则不是只出现一次的char</span></span><br><span class="line">    dic.put(c,!dic.containsKey(c));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c:sc)</span><br><span class="line">    <span class="comment">//只出现一次的key的value是true，如果dic,get()返回true，说明是我们要找的char</span></span><br><span class="line">    <span class="keyword">if</span> (dic.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Graph-DFS-amp-BFS"><a href="#Graph-DFS-amp-BFS" class="headerlink" title="Graph (DFS &amp; BFS)"></a>Graph (DFS &amp; BFS)</h2><h3 id="12-矩阵中的路径-DFS"><a href="#12-矩阵中的路径-DFS" class="headerlink" title="12-矩阵中的路径(DFS)"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">12-矩阵中的路径(DFS)</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_12_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ②</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=board.length || i&lt;<span class="number">0</span> || j&gt;=board[<span class="number">0</span>].length || j&lt;<span class="number">0</span> || board[i][j]!=word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//字符串 word 已全部匹配，即 k = len(word) - 1 。</span></span><br><span class="line">        <span class="keyword">if</span> (k==word.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//将当前char存起来</span></span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">//将当前char的位置标记为/，防治再次遍历当前的char，走回头路</span></span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">        <span class="comment">//可以上下左右移动，只要有一个方向符合要求就可以</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>) || dfs(board, word, i, j-<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, word, i-<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">                || dfs(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复char，因为其他递归里还需要走过这个char</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-机器人的运动范围-DFS"><a href="#13-机器人的运动范围-DFS" class="headerlink" title="13-机器人的运动范围(DFS)"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">13-机器人的运动范围(DFS)</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_13_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="comment">//辅助矩阵</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m=m;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> si, <span class="keyword">int</span> sj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=m || j&gt;=n || si+sj&gt;k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递推工作：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</span></span><br><span class="line"><span class="comment">         *     搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      	<span class="comment">//注意数位和的增量公式</span></span><br><span class="line">        <span class="comment">//(x + 1) % 10 != 0 ? s_x + 1 : s_x - 8</span></span><br><span class="line">        <span class="comment">//s_x为x的数位和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj)+dfs(i,j+<span class="number">1</span>,si,(j+<span class="number">1</span>)%<span class="number">10</span>!=<span class="number">0</span>?sj+<span class="number">1</span>:sj-<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Fibonacci-Dynamic-Programming"><a href="#Fibonacci-Dynamic-Programming" class="headerlink" title="Fibonacci (Dynamic Programming)"></a>Fibonacci (Dynamic Programming)</h2><h3 id="10-1-斐波拉契数列"><a href="#10-1-斐波拉契数列" class="headerlink" title="10-1-斐波拉契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">10-1-斐波拉契数列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fib_10_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果仅仅是用简单递归，在时间复杂度闪就会WA，然后就需要用动态规划的想法去简化计算量。</span></span><br><span class="line"><span class="comment">     * 对于这个问题，我的思路是从小到大算回去，把沿途的结果进行记录，推到n。</span></span><br><span class="line"><span class="comment">     * 关于题目描述中的取模这里提一句，要在计算中就取，不要等到结果再取，在计算过程中就已经达到取模要求了，如果没有取，可能会溢出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划解析：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     状态定义： 设 dp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 i 个数字 。</span></span><br><span class="line"><span class="comment">     *     转移方程： dp[i]=dp[i-1]+dp[i−2]，即对应数列定义 F(N) = F(N - 1) + F(N - 2)</span></span><br><span class="line"><span class="comment">     *     初始状态： dp[0]=1 dp[1]=1 ，即初始化前两个数字；</span></span><br><span class="line"><span class="comment">     *     返回值： dp[n]] ，即斐波那契数列的第 n 个数字。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_10_1_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//在计算中就曲摸，不然会溢出</span></span><br><span class="line">            dp[i] = dp[i]%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2-青蛙跳台阶问题 "></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">10-2-青蛙跳台阶问题 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">numWays_10_2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划解析：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     状态定义： 设 dp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 i 个数字 。</span></span><br><span class="line"><span class="comment">     *     转移方程： dp[i]=dp[i-1]+dp[i−2]，即对应数列定义 F(N) = F(N - 1) + F(N - 2)</span></span><br><span class="line"><span class="comment">     *     初始状态： dp[0]=1 dp[1]=1 dp[2]=2 ，即初始化前三个数字；</span></span><br><span class="line"><span class="comment">     *     返回值： dp[n]] ，即斐波那契数列的第 n 个数字。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_10_2_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Searching-Algorithms-Binary-Search"><a href="#Searching-Algorithms-Binary-Search" class="headerlink" title="Searching Algorithms (Binary Search)"></a>Searching Algorithms (Binary Search)</h2><h3 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04-二维数组中的查找 "></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">04-二维数组中的查找 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findNumberIn2DArray_04</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_04_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//线性查找 Linear Search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> i = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 则 int flag = matrix[i][j] 代表左下角元素（标志数）</span></span><br><span class="line"><span class="comment">         * 左下角元素： 为所在列最大元素，所在行最小元素</span></span><br><span class="line"><span class="comment">         * 如果flag大于target，就到上一行找，也就是i--，因为已知flag是所在行最小的元素</span></span><br><span class="line"><span class="comment">         * 如果flag小于target，就到下一列，j++，因为flag是这一列最大的元素</span></span><br><span class="line"><span class="comment">         * 如果flag ==  target，则return true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]&gt;target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]&lt;target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_04_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分查找  Binary Search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路分析：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 要查找矩阵中是否存在某个元素，并且表示矩阵每一行的数组都是有序的，可以对每一行进行二分查找，如果每一行都没有查找到结果，就返回false。</span></span><br><span class="line"><span class="comment">         *     使用java库函数Arrays.binarySearch(matrix[i], target)，返回值非负说明查找到target。</span></span><br><span class="line"><span class="comment">         * 还需要处理一些特殊情况：</span></span><br><span class="line"><span class="comment">         *     给定的矩阵为null或者给定的矩阵不存在任何元素matrix.length == 0 || matrix[0].length == 0，肯定找不到目标元素，直接返回。</span></span><br><span class="line"><span class="comment">         *     矩阵的每一列也是从小到达排列的，所以在对每一行进行二分查找的循环是，如果matrix[i][0] &gt; target，</span></span><br><span class="line"><span class="comment">         *     这一行肯定没有指定元素，更下面的每一行的所有元素都大于matrix[i][0]也一定找不到指定元素，所以可以直接返回false。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.binarySearch(matrix[i],target)是非零数则表示该行含有target</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.binarySearch(matrix[i],target)&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果matrix[i][0]&gt;target这一行就不包括target，因为matrix[i][0]是该行第一个元素，每一列和每一行都是递增的，如果第一个元素</span></span><br><span class="line">            <span class="comment">//都比target大，那说明该行不包含该元素，且因为递增，下一行的第一个元素一定比target大，所以return false结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-旋转数组的最小数字（二分查找）"><a href="#11-旋转数组的最小数字（二分查找）" class="headerlink" title="11-旋转数组的最小数字（二分查找）"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">11-旋转数组的最小数字（二分查找）</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">minArray_11</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_11_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//沙雕做法</span></span><br><span class="line">    <span class="comment">//笔试的时候可以用，面试别用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_11_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分搜索 Binary Search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设计两个指针i和j分别指向0和numbers.length-1</span></span><br><span class="line"><span class="comment">         * m = (i+j)/2 是中间数，那么会有三种情况</span></span><br><span class="line"><span class="comment">         * 1：numbers[m]&lt;numbers[j] 说明m在右边数组[m+1,j]，旋转点在[i,m], 所以更新j=m，m=(i+j)/2</span></span><br><span class="line"><span class="comment">         * 2：number[m]&gt;numbers[j] 说明m在左边数组,旋转点在[m+1,j]，所以更新i=m+1,m=(i+j)/2</span></span><br><span class="line"><span class="comment">         * 3：number[m]==numbers[j] 无法判断 mmm 在哪个排序数组中，即无法判断旋转点在 [i,m] 还是 [m+1,j] 区间中。</span></span><br><span class="line"><span class="comment">         * 解决方案： 执行 j=j−1 缩小判断范围</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j= numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m]&lt;numbers[j])&#123;</span><br><span class="line">                j=m;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[m]&gt;numbers[j])&#123;</span><br><span class="line">                i=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[m]==numbers[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_11_2</span></span>&#123;</span><br><span class="line">    <span class="comment">//暴力法 居然是这三种办法里最快的QAQ</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i]&lt;numbers[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1-数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">56-1-数组中数字出现的次数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleNumbers_56_1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 难点主要在于对mask的理解。mask是一个二进制数，且其中只有一位是1，其他位全是0，</span></span><br><span class="line"><span class="comment">     * 比如000010，表示我们用倒数第二位作为分组标准，倒数第二位是0的数字分到一组，倒数第二位是1的分到另一组。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么如何得到这个mask?因为我们分组的目的就是将两个不重复数字分开，</span></span><br><span class="line"><span class="comment">     * 这两个不重复数字的二进制表示肯定是不同的，但是我们没必要一位一位地比较，我们可以从右到左，找到第一个不相同的位，将mask当中这一位变成1,就得到了mask。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比如[2,2,3,3,4,6]中，不重复的两个数字是4，6，4和6的异或结果（也是整个数组的异或结果）是010，</span></span><br><span class="line"><span class="comment">     * 表示从右到左，第一次出现不同是在倒数第二位，那么可以确定，mask的倒数第二位是1，其他位是0，即</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_56_1_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//xor用来计算nums的异或和</span></span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算异或和 并存到xor</span></span><br><span class="line">        <span class="comment">// e.g. [2,4,2,3,3,6] 异或和：(2^2)^(3^3)^(4^6)=2=010</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) xor ^= num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置mask为1，则二进制为0001</span></span><br><span class="line">        <span class="comment">// mask是一个二进制数，且其中只有一位是1，其他位全是0，比如000010，</span></span><br><span class="line">        <span class="comment">// 表示我们用倒数第二位作为分组标准，倒数第二位是0的数字分到一组，倒数第二位是1的分到另一组</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &amp; operator只有1&amp;1时等于1 其余等于0</span></span><br><span class="line">        <span class="comment">// 用上面的e.g. 4和6的二进制是不同的 我们从右到左找到第一个不同的位就可以分组 4=0100 6=0110</span></span><br><span class="line">        <span class="comment">// 根据e.g. 010 &amp; 001 = 000 = 0则 mask=010</span></span><br><span class="line">        <span class="comment">// 010 &amp; 010 != 0 所以mask=010</span></span><br><span class="line">        <span class="comment">// 之后就可以用mask来将数组里的两个数分区分开</span></span><br><span class="line">        <span class="keyword">while</span>((xor &amp; mask)==<span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个只出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//根据&amp;是否为0区分将两个数字分区，并分别求异或和</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask)==<span class="number">0</span>) a ^= num;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Permutation"><a href="#Permutation" class="headerlink" title="Permutation"></a>Permutation</h2><h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38-字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/submissions/">38-字符串的排列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把参数string换为char数组</span></span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="comment">//记录每一种可能，最后转换成数组return</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        <span class="comment">//从c的第一位字符开始</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(x==c.length-<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(c));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">            <span class="comment">//HashSet用来剪枝，避免重复</span></span><br><span class="line">            <span class="comment">//例如 c=[a,b,b], 如果没有剪枝，就会有四个abb</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            <span class="comment">//e.g. c=[a,b,c]</span></span><br><span class="line">            <span class="comment">//这是第一层，也就是第一位上的字符的选择，通过调换来更换位置</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">            <span class="comment">//进入第二层，在e.g.第二层里会有两种选择，然后第二层里再递归第三层</span></span><br><span class="line">            <span class="comment">//第三层会出发终止条件 res会加上当前的可能</span></span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，把调换的位置再换回来</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42-连续子数组的最大和 "></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/submissions/">42-连续子数组的最大和 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//说明dp[i-1]对dp[i]是负贡献</span></span><br><span class="line">                <span class="comment">//dp[i-1]+nums[i]小于nums[i]</span></span><br><span class="line">                <span class="comment">//所以我们直接从当前nums[i]为开头的连续子数组来数就行</span></span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//不要用 Arrays.sort() 或者Arrays.stream().min().getAsInt()</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19-正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">19-正则表达式匹配</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Bitwise-Operation"><a href="#Bitwise-Operation" class="headerlink" title="Bitwise Operation"></a>Bitwise Operation</h2><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15-二进制中1的个数 "></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">15-二进制中1的个数 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n-1 代表 二进制n的最右边的1变成0，然后这个1右边的0变成1</span></span><br><span class="line">        <span class="comment">// n = n &amp; (n-1) 代表 二进制n最右边的1变成0，其余不变</span></span><br><span class="line">        <span class="comment">// e.g. n = 110001000 n-1=110000111</span></span><br><span class="line">        <span class="comment">// n &amp;= (n-1) -&gt; n = 110000000</span></span><br><span class="line">        <span class="comment">//在每一次循环中都消去n的最右边的1 并且res++ 当n中不含有1的时候终止循环</span></span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//n&amp;1只有两种可能分别是0和1</span></span><br><span class="line">            res += n&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//本题要求把数字 nnn 看作无符号数，因此使用 无符号右移 操作</span></span><br><span class="line">            <span class="comment">// java中是&gt;&gt;&gt;=</span></span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个是土方法做的 虽然能做出来但是时间空间复杂度高 性能差</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用Integer.toBinaryString().length来计算转换为二进制的数的长度</span></span><br><span class="line">        <span class="comment">// 也就是从二进制的一位一位的算</span></span><br><span class="line">        <span class="comment">// mask = 00000001</span></span><br><span class="line">        <span class="comment">// 如果 n&amp;mask !=0 说明 对应mask的1的位置的n的位置是1 则res++</span></span><br><span class="line">        <span class="comment">// 每次循环都将mask往左边移动 才检测n的左边一位是否是1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Integer.toBinaryString(n).length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; mask)!=<span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个是土方法做的 虽然能做出来但是时间空间复杂度高 性能差</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = Integer.toBinaryString(n).length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_15_4</span></span>&#123;</span><br><span class="line">    <span class="comment">//最简洁 = 性能最差哈哈哈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toBinaryString(n).replaceAll(<span class="string">"0"</span>, <span class="string">""</span>).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16-数值的整数次方 "></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">16-数值的整数次方 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_16_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//e.g. 2^10 x=2.0 n=9=1001</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//Java 代码中 int32 变量 n∈[−2147483648,2147483647],</span></span><br><span class="line">        <span class="comment">// 因此当 n=−2147483648n 时执行 n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</span></span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是n是负数就换成正数 x换成x^-1就行 也就是1/x</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// res = 1*2 = 2</span></span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Other-Algorithms"><a href="#Other-Algorithms" class="headerlink" title="Other Algorithms"></a>Other Algorithms</h2><h3 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05-替换空格 "></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05-替换空格 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_05_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//脑瘫做法哈哈 但是时间空间复杂度跟下面一样哈哈 笔试的时候真的可以用哈哈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>,<span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_05_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//脑瘫做法哈哈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在 Python 和 Java 等语言中，字符串都被设计成不可变的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21-调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">21-调整数组顺序使奇数位于偶数前面</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soulution_21_0</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不是同一时间 但是同一种土方法</span></span><br><span class="line">    <span class="comment">// 6%+95%</span></span><br><span class="line">    <span class="comment">// 性能感人 泪目了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list_1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list_2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="comment">//==0就是偶数</span></span><br><span class="line">            <span class="keyword">if</span> ((n&amp;<span class="number">1</span>)==<span class="number">0</span>) list_1.add(n);</span><br><span class="line">            <span class="comment">// ==1是奇数</span></span><br><span class="line">            <span class="keyword">if</span> ((n&amp;<span class="number">1</span>)==<span class="number">1</span>) list_2.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list_1.size()+list_2.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list_2.size();i++)&#123;</span><br><span class="line">            res[i] = list_2.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=list_2.size();i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i] = list_1.get(j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soulution_21_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//定义左右指针 和 tmp用来转换位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="comment">//思路就是</span></span><br><span class="line">            <span class="comment">//左指针找到左边第一个偶数</span></span><br><span class="line">            <span class="comment">//右指针找到右边第一个奇数</span></span><br><span class="line">            <span class="comment">//左右指针指向的数互换位置</span></span><br><span class="line">            <span class="comment">//这样的话 所有的操作都是基于参数nums 最后直接返回nums</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right &amp;&amp; (nums[left]&amp;<span class="number">1</span>)!=<span class="number">0</span>) left++;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right &amp;&amp; (nums[right]&amp;<span class="number">1</span>)!=<span class="number">1</span>) right--;</span><br><span class="line">            tmp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39-数组中出现次数超过一半的数字 "></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">39-数组中出现次数超过一半的数字 </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_39_0</span></span>&#123;</span><br><span class="line">    <span class="comment">// for each 版本的 HashMap做法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(n))&#123;</span><br><span class="line">                map.put(n,map.get(n)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(n,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resKey = <span class="number">0</span>;</span><br><span class="line">        Collection&lt;Integer&gt; c = map.values();</span><br><span class="line">        Object[] obj = c.toArray();</span><br><span class="line">        Arrays.sort(obj);</span><br><span class="line">        resValue = (<span class="keyword">int</span>)obj[obj.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(key).equals(resValue))&#123;</span><br><span class="line">                resKey = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soulution_39_1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出现次数大于nums的长度的一般</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//定义hashmap来统计每次数字出现次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//题目给出nums.length&gt;=1所以要考虑等于1的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="comment">//如果map包含当前的数字，则更新该数字的出现次数</span></span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果当前数字的value也就是出现次数大于nums的长度的一半就赋值给res</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[i])&gt;len)&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_39_2</span></span>&#123;</span><br><span class="line">    <span class="comment">//排序法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_39_3</span></span>&#123;</span><br><span class="line">    <span class="comment">//摩尔投票法 最优解</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法原理：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     为构建正负抵消，假设数组首个元素 n1​ 为众数，遍历统计票数，当发生正负抵消时，剩余数组的众数一定不变 ，这是因为（设真正的众数为 x ）：</span></span><br><span class="line"><span class="comment">     *         当 n1=x： 抵消的所有数字中，有一半是众数 x 。</span></span><br><span class="line"><span class="comment">     *         当 n1≠x ： 抵消的所有数字中，少于或等于一半是众数 x 。</span></span><br><span class="line"><span class="comment">     *     利用此特性，每轮假设都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 算法流程:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *     初始化： 票数统计 votes=0， 众数 x；</span></span><br><span class="line"><span class="comment">         *     循环抵消： 遍历数组 nums 中的每个数字 num ；</span></span><br><span class="line"><span class="comment">         *         当 票数 votes 等于 0 ，则假设 当前数字 numn 为 众数 x ；</span></span><br><span class="line"><span class="comment">         *         当 num=x时，票数 votes 自增 1 ；否则，票数 voteses 自减 1 。</span></span><br><span class="line"><span class="comment">         *     返回值： 返回 众数 x 即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> vote = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vote==<span class="number">0</span>) x = num;</span><br><span class="line">            <span class="keyword">if</span> (num==x)&#123;</span><br><span class="line">                vote++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                vote--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="43-1～n整数中1出现的次数-妖魔算法题"><a href="#43-1～n整数中1出现的次数-妖魔算法题" class="headerlink" title="43-1～n整数中1出现的次数(妖魔算法题) "></a><a href="">43-1～n整数中1出现的次数(妖魔算法题) </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">countDigitOne_43</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(<span class="number">2345</span>);</span><br><span class="line">        <span class="comment">// char类型的s.chartAt(0)是2</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//但是把s.chartAt(0)强制转换为int是不行的</span></span><br><span class="line">        <span class="keyword">int</span> test = (<span class="keyword">int</span>) s.charAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        <span class="comment">// 有两种办法</span></span><br><span class="line">        <span class="comment">//第一种 用char的封装累的静态方法</span></span><br><span class="line">        <span class="keyword">int</span> high_0 = Character.getNumericValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(high_0);</span><br><span class="line">        <span class="comment">//第二种 直接 -'0' 就可以得到准确的int</span></span><br><span class="line">        <span class="keyword">int</span> high_1 = s.charAt(<span class="number">0</span>) - <span class="string">'0'</span>;</span><br><span class="line">        System.out.println(high_1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_43_0</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把int转为string</span></span><br><span class="line">        String s = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> high = s.charAt(<span class="number">0</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> pow = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = n-high*pow;</span><br><span class="line">        <span class="keyword">if</span> (high == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> d(pow-<span class="number">1</span>)+d(last)+(last+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pow + high*d(pow-<span class="number">1</span>) + d(last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="45-把数组排成最小的数-妖魔算法题"><a href="#45-把数组排成最小的数-妖魔算法题" class="headerlink" title="45-把数组排成最小的数(妖魔算法题) "></a><a href="">45-把数组排成最小的数(妖魔算法题) </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_45_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序判断规则： 设 nums 任意两数字的字符串格式 x 和 y ，则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     若拼接字符串 x+y&gt;y+x，则 m&gt;n；</span></span><br><span class="line"><span class="comment">     *     反之，若 x+y&lt;y+xx，则 n&lt;m；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串列表 strs ，保存各数字的字符串格式</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用以上 “排序判断规则” ，对 strs 执行排序；</span></span><br><span class="line">        Arrays.sort(strs, (x,y) -&gt; (x+y).compareTo(y+x));</span><br><span class="line">        <span class="comment">//拼接 strs 中的所有字符串，并返回</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="49-丑数-妖魔算法题"><a href="#49-丑数-妖魔算法题" class="headerlink" title="49-丑数 (妖魔算法题)"></a><a href="">49-丑数 (妖魔算法题)</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_49_0</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义三个指针p2,p3,p5，p2指向的数字永远乘2，p3指向的数字永远乘3，p5指向的数字永远乘5</span></span><br><span class="line"><span class="comment">     * 初始化所有指针都指向第一个丑数，即1</span></span><br><span class="line"><span class="comment">     * 我们从2*dp[p2], 3*dp[p3], 5*dp[p5]选取最小的一个数字，作为新的丑数。这边新的丑数就是2*dp[p2]=2*1=2，然后p2++</span></span><br><span class="line"><span class="comment">     * 此时p3和p5指向第1个丑数，p2指向第2个丑数。然后重复上一步</span></span><br><span class="line"><span class="comment">     * 这里基于的一个事实是，丑数数列是递增的，当p5指针在当前位置时，</span></span><br><span class="line"><span class="comment">     * 后面的数乘以5必然比前面的数乘以5大，所以下一个丑数必然是先考虑前面的数乘以5。p2,p3同理，所以才可以使用指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>, p3=<span class="number">0</span>, p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[p2]*<span class="number">2</span>,Math.min(dp[p3]*<span class="number">3</span>,dp[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (dp[i]==dp[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]==dp[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]==dp[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="57-2-和为S的连续正数序列-滑动窗口思想"><a href="#57-2-和为S的连续正数序列-滑动窗口思想" class="headerlink" title="57-2-和为S的连续正数序列(滑动窗口思想) "></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">57-2-和为S的连续正数序列(滑动窗口思想) </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findContinuousSequence_57_2</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口是数组中框起来的一部分，我们可以用滑动窗口观察所有可能的结果，当窗口从数组左边滑到数组右边，我们可以从中找出最优解</span></span><br><span class="line"><span class="comment"> * 对于这道题来说，数组就是正整数序列 [1,2,3,...n] 。我们设滑动窗口的左边界为 i，右边界为 j，</span></span><br><span class="line"><span class="comment"> * 则滑动窗口框起来的是一个左闭右开区间 [i,j)。注意，为了编程的方便，滑动窗口一般表示成一个左闭右开区间。</span></span><br><span class="line"><span class="comment"> * 在一开始，i=1,j=1，滑动窗口位于序列的最左侧，窗口大小为零。</span></span><br><span class="line"><span class="comment"> * 滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在这道题中，我们关注的是滑动窗口中所有数的和。当滑动窗口的右边界向右移动时，也就是 j = j + 1，窗口中多了一个数字 j，</span></span><br><span class="line"><span class="comment"> * 窗口的和也就要加上 j。当滑动窗口的左边界向右移动时，也就是 i = i + 1，窗口中少了一个数字 i，窗口的和也就要减去 i。</span></span><br><span class="line"><span class="comment"> * 滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口） 两个操作，所以实际上非常简单。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_57_2_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//左右边界必须从1开始，不能为0，否则会出现[0,1,2,3,...,n]的非法集合</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// 滑动窗口左边界</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">// 滑动窗口右边界</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 窗口中的和</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 储存可能的数组</span></span><br><span class="line">        <span class="comment">//因为序列是连续的 当i=target/2时下一个比i大1，加起来就超过target了，题目要求最少两个整数</span></span><br><span class="line">        <span class="comment">//拿target=9举例，当i=5的时候没有必要接着遍历下去了，题目说数组递增，所以下一个数比5大，加起来也肯定大于9</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=target/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&lt;target)&#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;target)&#123;</span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    res[k-i] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(res);</span><br><span class="line">                <span class="comment">//左边边界向右移动1位</span></span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="57-和为S的两个数字-双指针思想"><a href="#57-和为S的两个数字-双指针思想" class="headerlink" title="57-和为S的两个数字(双指针思想)"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">57-和为S的两个数字(双指针思想)</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twoSum_57</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soulution_57_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//憨憨做法哈哈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="comment">//HashSet做法</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//将每一个nums中的数字添加到set中</span></span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//对于nums中的每一个数字，求出与target的差，如果set包含这个差的数字则返回</span></span><br><span class="line">            <span class="keyword">int</span> dif = target - num;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(dif))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dif,num&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_57_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//个人双指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="comment">//左右指针分别指向0和1</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left]+nums[right]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[left],nums[right]&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left]+nums[right]&lt;target)&#123;</span><br><span class="line">                <span class="comment">//因为nums是递增的，所以left++</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left]+nums[right]&gt;target)&#123;</span><br><span class="line">                <span class="comment">//同理</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="58-2-左旋转字符串-矩阵翻转"><a href="#58-2-左旋转字符串-矩阵翻转" class="headerlink" title="58-2-左旋转字符串(矩阵翻转) "></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">58-2-左旋转字符串(矩阵翻转) </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_58_2_0</span></span>&#123;</span><br><span class="line">    <span class="comment">// 字符串切片 substring()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//翻转之后前面的字符串</span></span><br><span class="line">        String first = s.substring(n,s.length());</span><br><span class="line">        <span class="comment">//翻转之后后面的字符串</span></span><br><span class="line">        String second = s.substring(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> first+second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_58_2_1</span></span>&#123;</span><br><span class="line">    <span class="comment">// 列表遍历拼接 利用charAt()方法找到每一个string中的char 然后依次添加到StringBuilder对象中去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//先把从n到尾的char添加到sb</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&lt;s.length();i++)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再把0到n添加到sb</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_58_2_2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 字符串遍历拼接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//先把从n到尾的char添加到res</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&lt;s.length();i++)&#123;</span><br><span class="line">            res += (s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再把0到n添加到res</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res += (s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="62-圆圈中最后剩下的数-约瑟夫环"><a href="#62-圆圈中最后剩下的数-约瑟夫环" class="headerlink" title="62-圆圈中最后剩下的数(约瑟夫环) "></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">62-圆圈中最后剩下的数(约瑟夫环) </a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_62_0</span></span>&#123;</span><br><span class="line">    <span class="comment">//Arraylist做法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前删除位</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            x = (x+m-<span class="number">1</span>)%n;</span><br><span class="line">            <span class="comment">//删除x位置上的元素</span></span><br><span class="line">            list.remove(x);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_62_1</span></span>&#123;</span><br><span class="line">    <span class="comment">//约瑟夫环的数学做法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n = 5, m = 3</span></span><br><span class="line"><span class="comment">     * 第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后剩下的数字是 3。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 图中的绿色的线指的是新的一轮的开头是怎么指定的，每次都是固定地向前移位 mmm 个位置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后剩下的 3 的下标是 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第四轮反推，补上 mmm 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第三轮反推，补上 mmm 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第二轮反推，补上 mmm 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一轮反推，补上 mmm 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最后一轮剩俩人 所以从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res = (res+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66-构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">66-构建乘积数组</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_66_0</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这道题的思路就是：</span></span><br><span class="line"><span class="comment">        求出当前元素的左右乘积并分别存到不同的数组里</span></span><br><span class="line"><span class="comment">        最后用左右乘积的数组相乘得到答案</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (a.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] leftRes = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="comment">//第一位总是0，因为第一位的左边没有元素</span></span><br><span class="line">            leftRes[i] = left;</span><br><span class="line">            <span class="comment">//更新left</span></span><br><span class="line">            left *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边同理</span></span><br><span class="line">        <span class="keyword">int</span>[] rightRes = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightRes[i] = right;</span><br><span class="line">            right*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            res[i] = leftRes[i]*rightRes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency</title>
    <url>/2020/04/09/Java-Concurrency/</url>
    <content><![CDATA[<h1 id="Java-Concurrency"><a href="#Java-Concurrency" class="headerlink" title="Java Concurrency"></a>Java Concurrency</h1><p>This article is from <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#countdownlatch">here</a> and I made some notes on it to review java concurrency.</p>
<p>If it’s inappropriate to do so, contact me to delete this post.</p>
<h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><p>有<u><strong>三种</strong></u>使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<a id="more"></a>

<p><u>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。</u>可以理解为任务是通过线程驱动从而执行的。</p>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>需要实现接口中的 run() 方法。<strong>任务写在run()方法中，然后用Thread 调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><p><u><strong>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</strong></u></p>
<p><strong>实现Runnable需要实现接口中的void返回值的run( )方法，Callable则实现<E>当初定义返回值的call( )方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p><strong><u>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</u></strong></p>
<p><strong>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p>
<ul>
<li><strong>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口</strong>；</li>
<li>类可能只要求可执行就行，<strong>继承整个 Thread 类开销过大</strong>。</li>
</ul>
<h1 id="二、基础线程机制"><a href="#二、基础线程机制" class="headerlink" title="二、基础线程机制"></a>二、基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<p>先实现Runnable创建一个线程，定义run( )方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建CachedThreadPool，并在for循环中执行MyRunnable中的run( )方法5次，最后关闭CachedThreadPool</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p><strong><u>守护线程是程序运行时在后台提供服务的线程</u></strong>，不属于程序中不可或缺的部分。</p>
<p><strong><u>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</u></strong>。</p>
<p><strong><em>main() 属于非守护线程</em></strong>。</p>
<p><strong><u>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>Thread.sleep(millisec) 方法会<u><strong>休眠当前正在执行的线程</strong></u>，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 <strong>InterruptedException</strong>，<strong><u>因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理</u></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>对静态方法 Thread.yield() 的调用声明了<strong><em>当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行</em></strong>。<strong><u>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行</u></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、中断"><a href="#三、中断" class="headerlink" title="三、中断"></a>三、中断</h1><p><strong><u>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</u></strong></p>
<h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 <strong>interrupt()</strong> 来中断该线程，<strong><u>如果该线程处于阻塞(BLOCKED)、限期等待(TIMED_WAITING)或者无限期等待(WAITINNG)状态，那么就会抛出 InterruptedException，从而提前结束该线程</u></strong>。<strong>但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</strong></p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，Thread会进入TIMED_WAITING状态，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);<span class="comment">//线程进入TIMED_WAITING状态</span></span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();<span class="comment">//因为线程是TIMED_WAITING状态，调用Interrup()会抛出异常从而结束该线程</span></span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>



<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个<strong>无限循环</strong>，<strong><u>并且没有执行 sleep() 等会抛出 InterruptedException 的操作</u></strong>，<strong><u>那么调用线程的 interrupt() 方法就无法使线程提前结束</u></strong>。</p>
<p>但是调用 interrupt() 方法会<strong><u>设置线程的中断标记</u></strong>，此时调用 interrupted() 方法会返回 <strong>true</strong>。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 没有调用interrupt方法之前，interrupted方法返回的都是false，所以会一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt(); <span class="comment">//调用之后，interrupted方法返回true从而结束循环，结束线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread end</span><br></pre></td></tr></table></figure>



<h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><p><strong><u>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</u></strong></p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$<span class="number">0</span>(ExecutorInterruptExample.java:<span class="number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$<span class="number">1</span>/<span class="number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<h1 id="四、互斥同步"><a href="#四、互斥同步" class="headerlink" title="四、互斥同步"></a>四、互斥同步</h1><p>Java 提供了<strong>两种锁机制</strong>来<strong>控制多个线程对共享资源的互斥访问</strong>，第一个是 JVM 实现的 <strong>synchronized</strong>，而另一个是 JDK 实现的 <strong>ReentrantLock</strong>。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它只作用于同一个对象</strong>，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是<strong>同一个对象</strong>的同步代码块，<strong><u>因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>对于以下代码，<strong><u>两个线程调用了不同对象的同步代码块</u></strong>，<strong><u>因此这两个线程就不需要同步</u></strong>。从输出结果可以看出，两个线程<strong>交叉执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1()); <span class="comment">//lamba表达式来实现new Runnable并在run方法里调用e.func1()</span></span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 同步一个方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和同步代码块一样，作用于同一个对象。</p>
<p><strong>3. 同步一个类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 同步一个静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>



<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p><u>ReentrantLock 可中断，而 synchronized 不行。</u></p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定<u>多个 Condition 对象</u>。</p>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是  JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用  synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h1 id="五、线程之间的协作"><a href="#五、线程之间的协作" class="headerlink" title="五、线程之间的协作"></a>五、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p><u>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</u></p>
<p>对于以下代码，<u>虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>



<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 <strong>wait()</strong> 使得线程<strong>等待某个条件满足</strong>，<strong>线程在等待时会被挂起</strong>，当<strong>其他线程</strong>的运行使得这个<strong>条件满足</strong>时，其它线程会调用 <strong>notify()</strong> 或者 <strong>notifyAll()</strong> 来唤醒挂起的线程。</p>
<p>它们都属于 <strong>Object</strong> 的一部分，而不属于 <strong>Thread</strong>。</p>
<p><u><strong>只能用在同步方法或者同步控制块中使用</strong></u>，否则会在运行时抛出 <strong>IllegalMonitorStateException</strong>。</p>
<p><u>使用 wait() 挂起期间，<strong>线程会释放锁</strong>。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());<span class="comment">//wait()将当前线程挂起，线程释放锁，这样才能执行before方法中的notifyAll方法来唤醒被挂起的线程，否则死锁</span></span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li><strong>wait() 会释放锁，sleep() 和yield()不会。</strong></li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>java.util.concurrent 类库中提供了 <strong>Condition</strong> 类来实现线程之间的协调，可以在 Condition 上调用 <strong>await()</strong> 方法使线程等待，其它线程调用 <strong>signal()</strong> 或 <strong>signalAll()</strong> 方法唤醒等待的线程。</p>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 <strong>Lock</strong> 来获取一个 <strong>Condition</strong> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//boolean await()</span></span><br><span class="line">          <span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span><br><span class="line">          <span class="comment">//boolean await(long time, TimeUnit unit)</span></span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<h1 id="六、线程状态"><a href="#六、线程状态" class="headerlink" title="六、线程状态"></a>六、线程状态</h1><p><strong>一个线程只能处于一种状态</strong>，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p>
<h2 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h2><p>创建后尚未启动。</p>
<h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。<strong>所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</strong></p>
<h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。<strong>线程A先访问sychronized代码块，线程B再访问需要请求该代码块的monitor lock，但是发现线程A已经占用了该monitor lock，所以线程B现在的状态是BLOCK</strong></p>
<h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其它线程显式地唤醒。</p>
<p><strong>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用  Object.wait() 等方法进入。</strong></p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="限期等待（TIMED-WAITING）"><a href="#限期等待（TIMED-WAITING）" class="headerlink" title="限期等待（TIMED_WAITING）"></a>限期等待（TIMED_WAITING）</h2><p>无需等待其它线程显式地唤醒，<strong>在一定时间之后会被系统自动唤醒。</strong></p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<p><strong><u>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait()  方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</u></strong></p>
<h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html">Java SE 9 Enum Thread.State</a></p>
<h1 id="七、J-U-C-AQS"><a href="#七、J-U-C-AQS" class="headerlink" title="七、J.U.C - AQS"></a>七、J.U.C - AQS</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><strong><u>用来控制一个或者多个线程等待多个线程</u></strong>。</p>
<p>维护了一个计数器 cnt，每次调用 <strong>countDown()</strong> 方法会让计数器的值<strong>减 1</strong>，<u>减到 0 的时候，那些因为调用 <strong>await()</strong> 方法而在等待的线程就会被唤醒。</u></p>
<p>利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p>
<p> <a href="https://camo.githubusercontent.com/c2a94b75d7379c204996f24411a9c497125cfa06/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62613037383239312d373931652d343337382d623664312d6563653736633266306231342e706e67"><img src="https://camo.githubusercontent.com/c2a94b75d7379c204996f24411a9c497125cfa06/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62613037383239312d373931652d343337382d623664312d6563653736633266306231342e706e67" alt="img"></a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"等待2个子线程执行完毕..."</span>);</span><br><span class="line">            latch.await();<span class="comment">//挂起主线程，让两个子线程执行完毕</span></span><br><span class="line">          <span class="comment">//当两个子线程都countDown()之后，计数器的值为0，被挂起的主线程被唤醒继续执行</span></span><br><span class="line">            System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">            System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等待<span class="number">2</span>个子线程执行完毕...</span><br><span class="line">子线程Thread-<span class="number">1</span>正在执行</span><br><span class="line">子线程Thread-<span class="number">0</span>正在执行</span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line"><span class="number">2</span>个子线程已经执行完毕</span><br><span class="line">继续执行主线程</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><u><strong>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</strong></u></p>
<p>和 CountdownLatch 相似，都是通过<u><strong>维护计数器</strong></u>来实现的。<u>线程执行 <strong>await()</strong> 方法之后计数器会减 1</u>，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p><u><strong>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</strong></u></p>
<p><u><strong>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <a href="https://camo.githubusercontent.com/10dd07a9c7828fab8f68a0f953755869dc286a8e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66373161663636622d306435342d343339392d613434622d6634376235383332313938342e706e67"><img src="https://camo.githubusercontent.com/10dd07a9c7828fab8f68a0f953755869dc286a8e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66373161663636622d306435342d343339392d613434622d6634376235383332313938342e706e67" alt="img"></a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();<span class="comment">//挂起线程，并将计数器-1，计数器为0时才会释放线程往下执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，<strong><u>可以控制对互斥资源的访问线程数</u></strong>。</p>
<p>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);<span class="comment">//允许三个线程进行访问</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//获得一个许可</span></span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);<span class="comment">//当前可用的许可数目</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放一个许可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>



<h1 id="八、J-U-C-其它组件"><a href="#八、J-U-C-其它组件" class="headerlink" title="八、J.U.C - 其它组件"></a>八、J.U.C - 其它组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了  RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，<strong><u>这使得 FutureTask  既可以当做一个任务执行，也可以有返回值。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>FutureTask</em></strong> 可用于<strong>异步获取执行结果或取消执行任务</strong>的场景。<u><strong>当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//在FutureTask里分配任务，FT里面可以放Runnable对象，实现Runnable对象的run或者call函数来设置任务</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为这个FT的任务需要很长时间，先分配一个线程来计算</span></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为第一个线程要计算很久，我们可以先执行其他的线程，最后取回计算很久的线程的计算结果</span></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());<span class="comment">//最后取回计算结果</span></span><br><span class="line">&#125;</span><br><span class="line">other task is running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>



<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li><strong>FIFO 队列</strong>  ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li><strong>优先级队列</strong>  ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：<strong><u>如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</u></strong></p>
<p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//put与take相互抵消</span></span><br><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></figure>



<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，<strong><u>都是把大的计算任务拆分成多个小任务并行计算</u></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 实现了<u><strong>工作窃取算法</strong></u>来提高 CPU  的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2  来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<p> <a href="https://camo.githubusercontent.com/b06eff6a60482e87b9ded90d6df90f9b47370f84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65343266313838662d663461392d346536662d383866632d3435663436383230373266622e706e67"><img src="https://camo.githubusercontent.com/b06eff6a60482e87b9ded90d6df90f9b47370f84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65343266313838662d663461392d346536662d383866632d3435663436383230373266622e706e67" alt="img"></a> </p>
<h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p><u>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</u></p>
<p><u>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">997</span></span><br></pre></td></tr></table></figure>



<h1 id="十、Java-内存模型"><a href="#十、Java-内存模型" class="headerlink" title="十、Java 内存模型"></a>十、Java 内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<p> <a href="https://camo.githubusercontent.com/7e289aaee2d8533d8870f92659a8984be81eb432/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343263613064322d396435632d343561342d383963622d3566643839623631393133662e706e67"><img src="https://camo.githubusercontent.com/7e289aaee2d8533d8870f92659a8984be81eb432/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343263613064322d396435632d343561342d383963622d3566643839623631393133662e706e67" alt="img"></a> </p>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<p> <a href="https://camo.githubusercontent.com/fce232dcfc7411192b429ae86765aa9bef029427/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353835313535352d356162632d343937642d616433342d6566656431306634336136622e706e67"><img src="https://camo.githubusercontent.com/fce232dcfc7411192b429ae86765aa9bef029427/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353835313535352d356162632d343937642d616433342d6566656431306634336136622e706e67" alt="img"></a> </p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<p> <a href="https://camo.githubusercontent.com/42696b8f0b2cfbf78024f9cd0d806e0e6decb5fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38623765626261642d393630342d343337352d383465332d6634313230393964313730632e706e67"><img src="https://camo.githubusercontent.com/42696b8f0b2cfbf78024f9cd0d806e0e6decb5fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38623765626261642d393630342d343337352d383465332d6634313230393964313730632e706e67" alt="img"></a> </p>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock  操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被  volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改  cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。<u><strong>因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</strong></u></p>
<p> <a href="https://camo.githubusercontent.com/430b45d369c24a65e4a4641f52b14aaa95d41c7c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373937613630392d363864622d346437622d383730312d3431616339613334623134662e6a7067"><img src="https://camo.githubusercontent.com/430b45d369c24a65e4a4641f52b14aaa95d41c7c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373937613630392d363864622d346437622d383730312d3431616339613334623134662e6a7067" alt="img"></a> </p>
<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<p> <a href="https://camo.githubusercontent.com/b77a1a0dc9c2a35d056d0c76b75df18226283040/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64643536333033372d666361612d346264382d383362362d6233396439336131326337372e6a7067"><img src="https://camo.githubusercontent.com/b77a1a0dc9c2a35d056d0c76b75df18226283040/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64643536333033372d666361612d346264382d383362362d6233396439336131326337372e6a7067" alt="img"></a> </p>
<p><u><strong>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicExample example = <span class="keyword">new</span> AtomicExample(); <span class="comment">// 只修改这条语句</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p><u><strong>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicSynchronizedExample example = <span class="keyword">new</span> AtomicSynchronizedExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性指当<u><strong>一个线程修改了共享变量的值</strong></u>，<u><strong>其它线程能够立即得知这个修改</strong></u>。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p><u><strong>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</strong></u></p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p><strong><u>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</u></strong>。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p><strong><u>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</u></strong></p>
<p><strong><u>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</u></strong></p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h3><blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<p> <a href="https://camo.githubusercontent.com/e1c3998ce9151df8d6b226e640270efff94df669/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38373462336666372d376335632d346537612d623861622d6138326133653033386432302e706e67"><img src="https://camo.githubusercontent.com/e1c3998ce9151df8d6b226e640270efff94df669/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38373462336666372d376335632d346537612d623861622d6138326133653033386432302e706e67" alt="img"></a> </p>
<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2. 管程锁定规则"></a>2. 管程锁定规则</h3><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<p> <a href="https://camo.githubusercontent.com/c86b5efc7f2ba505380081f0a343e72a862394f0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38393936613533372d376334612d346563382d613362372d3765663137393865616532362e706e67"><img src="https://camo.githubusercontent.com/c86b5efc7f2ba505380081f0a343e72a862394f0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38393936613533372d376334612d346563382d613362372d3765663137393865616532362e706e67" alt="img"></a> </p>
<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h3><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p><strong><u>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</u></strong>。</p>
<p> <a href="https://camo.githubusercontent.com/4cba332d162065020d289fbb116e50465ceb0e15/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343266333363392d386164392d343938372d383336662d3030376465346332316465302e706e67"><img src="https://camo.githubusercontent.com/4cba332d162065020d289fbb116e50465ceb0e15/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343266333363392d386164392d343938372d383336662d3030376465346332316465302e706e67" alt="img"></a> </p>
<h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h3><blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<p> <a href="https://camo.githubusercontent.com/6a64fb5055e471c6de4363bee031982bb42200d9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323730633231362d376563302d346462372d393464652d3030303362636533376364322e706e67"><img src="https://camo.githubusercontent.com/6a64fb5055e471c6de4363bee031982bb42200d9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323730633231362d376563302d346462372d393464652d3030303362636533376364322e706e67" alt="img"></a> </p>
<h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h3 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h3><blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<p> <a href="https://camo.githubusercontent.com/17e6baed6955e119c1e512d6ceef339002b343e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32333366386438392d333164372d343133662d396330322d3034326631396334366261312e706e67"><img src="https://camo.githubusercontent.com/17e6baed6955e119c1e512d6ceef339002b343e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32333366386438392d333164372d343133662d396330322d3034326631396334366261312e706e67" alt="img"></a> </p>
<h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><h3 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h3><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h3 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h3><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
<h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><h3 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h3><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>定义：<strong><u>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</u></strong></p>
<p>线程安全有以下几种实现方式：</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变（<strong>Immutable</strong>）的对象<strong><u>一定是线程安全的</u></strong>，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。<strong><u>但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</u></strong></li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">"a"</span>, <span class="number">1</span>);<span class="comment">//这里修改Map会抛出异常，因为unmodifiableMap()是对原始的集合的拷贝，任何对集合进行修改的方法都会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="number">1457</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p><strong><u>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p><strong>synchronized</strong> 和 <strong>ReentrantLock</strong>。</p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p><strong>乐观锁</strong>需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><h3 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4  指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用  compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2  的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><h3 id="3-ABA"><a href="#3-ABA" class="headerlink" title="3. ABA"></a>3. ABA</h3><p><u><strong>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</strong></u></p>
<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference  来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA  问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><h3 id="1-栈封闭"><a href="#1-栈封闭" class="headerlink" title="1. 栈封闭"></a>1. 栈封闭</h3><p><u><strong>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="2-线程本地存储（Thread-Local-Storage）"><a href="#2-线程本地存储（Thread-Local-Storage）" class="headerlink" title="2. 线程本地存储（Thread Local Storage）"></a>2. 线程本地存储（Thread Local Storage）</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web  服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>为了理解 ThreadLocal，先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它所对应的底层结构图为：</p>
<p> <a href="https://camo.githubusercontent.com/8968de525ae8f2712bd1c0c6a5f43a404dc2955c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373832363734632d316266652d343837392d616633392d6539643732326139356433392e706e67"><img src="https://camo.githubusercontent.com/8968de525ae8f2712bd1c0c6a5f43a404dc2955c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373832363734632d316266652d343837392d616633392d6539643732326139356433392e706e67" alt="img"></a> </p>
<p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 方法类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致  ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现  ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h3 id="3-可重入代码（Reentrant-Code）"><a href="#3-可重入代码（Reentrant-Code）" class="headerlink" title="3. 可重入代码（Reentrant Code）"></a>3. 可重入代码（Reentrant Code）</h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h1 id="十二、锁优化"><a href="#十二、锁优化" class="headerlink" title="十二、锁优化"></a>十二、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()  方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append()  方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<p> <a href="https://camo.githubusercontent.com/deab9b2c52091554cc095249fd7a97fc1ca41521/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62623661343962652d303066322d346632372d613063652d3465643736346263363035632e706e67"><img src="https://camo.githubusercontent.com/deab9b2c52091554cc095249fd7a97fc1ca41521/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62623661343962652d303066322d346632372d613063652d3465643736346263363035632e706e67" alt="img"></a> </p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<p> <a href="https://camo.githubusercontent.com/c1a0307ca4be2bc4b5a3492c634553b4255759bd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30353165343336632d306534362d346335392d386636372d3532643839643635363138322e706e67"><img src="https://camo.githubusercontent.com/c1a0307ca4be2bc4b5a3492c634553b4255759bd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30353165343336632d306534362d346335392d386636372d3532643839643635363138322e706e67" alt="img"></a> </p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建  Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS  操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p> <a href="https://camo.githubusercontent.com/740f6e8b42fda5eaca9b83b919a1729059653705/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62616161363831662d376335322d343139382d613561652d3330336239333836636634372e706e67"><img src="https://camo.githubusercontent.com/740f6e8b42fda5eaca9b83b919a1729059653705/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62616161363831662d376335322d343139382d613561652d3330336239333836636634372e706e67" alt="img"></a> </p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word  是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<p> <a href="https://camo.githubusercontent.com/8369c6bebffb9617694168381f5d7a62bb099e62/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393063393133622d356633312d343434662d626264622d3262383862363838653763652e6a7067"><img src="https://camo.githubusercontent.com/8369c6bebffb9617694168381f5d7a62bb099e62/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393063393133622d356633312d343434662d626264622d3262383862363838653763652e6a7067" alt="img"></a> </p>
<h1 id="十三、多线程开发良好的实践"><a href="#十三、多线程开发良好的实践" class="headerlink" title="十三、多线程开发良好的实践"></a>十三、多线程开发良好的实践</h1><ul>
<li>给线程起个有意义的名字，这样可以方便找 Bug。</li>
<li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li>
<li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier,  Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify()  很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li>
<li>使用 BlockingQueue 实现生产者消费者问题。</li>
<li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li>
<li>使用本地变量和不可变类来保证线程安全。</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
</search>
